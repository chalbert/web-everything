---
pagination:
    data: projects
    size: 1
    alias: project
permalink: "projects/{{ project.id }}/"
layout: base.njk
eleventyComputed:
    title: "Web Everything - {{ project.name }}"
---

{% from "project-status.njk" import projectStatus %}

<div class="project-detail-header">
    <div class="project-detail-icon">
        {% if project.isSvg %}
            <img src="{{ project.icon }}" alt="{{ project.name }} icon" width="64" height="64">
        {% else %}
            {{ project.icon }}
        {% endif %}
    </div>
    <h1 class="project-detail-title">{{ project.name }}</h1>
    <p class="project-detail-desc">{{ project.description }}</p>
    
    <div class="project-detail-status">
        <!-- Status Link -->
        <a href="/project-lifecycle/" class="status-lifecycle-link" aria-label="Learn about the project lifestyle stages">
            {{ projectStatus(project.status) }}
        </a>
    </div>
</div>

<article class="project-content">
    <h2>Mission Brief</h2>
    {% if project.details %}
        <p>{{ project.details }}</p>
    {% else %}
        <p>This project is currently in the <strong>{{ project.status }}</strong> phase. 
        We are working hard to bring this standard to life.</p>
        <p>Stay tuned for updates!</p>
    {% endif %}

    {% if project.id == 'webinjectors' %}
    <h3>The Problem</h3>
    <p>Loading dependencies in the browser without build tools is hard. Import maps are static and location-based. We need something dynamic.</p>
    
    <h3>The Solution: Web Injectors</h3>
    <p>Web Injectors bring standard dependency injection to the web. It separates the "what" from the "where" and "how".</p>
    
    <h4>Key Concepts</h4>
    <ul>
        <li><strong>Injector:</strong> A container that holds dependencies.</li>
        <li><strong>Scope:</strong> An isolated context for dependencies.</li>
        <li><strong>Provide:</strong> Declare what data flows out of a scope.</li>
        <li><strong>Consume:</strong> Declare what data is needed.</li>
    </ul>

    {% highlight "javascript" %}
// Example Syntax
scope myScope {
    const value = 42;
    provide { value };
}
    {% endhighlight %}
    {% endif %}

    {% if project.id == 'webregistries' %}
    <h3>The Protocol</h3>
    <p>
        <strong>Web Registries</strong> define a standard interface for creating scoped, hierarchical registries on the web platform. 
        Where standard <code>Map</code> or <code>CustomElementRegistry</code> are flat and global, Web Registries are designed for **inheritance** and **scoping**.
    </p>

    <h3>Key Features</h3>
    <ul>
        <li><strong>Standard Interface:</strong> All registries implement a common <code>get</code>, <code>has</code>, <code>set</code> (via <code>define</code>) API.</li>
        <li><strong>Inheritance:</strong> A registry can extend one or more parent registries. Lookups traverse the chain automatically.</li>
        <li><strong>Scoping:</strong> Enables different parts of an application to have different definitions for the same key (e.g., scoping icons or formatters to a specific routed view).</li>
    </ul>

    <h3>Proposed Standards</h3>
    <p>The <strong>Web Everything</strong> platform proposes standardizing registries for nearly every aspect of the DOM, allowing for unprecedented extensibility:</p>
    
    <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
        <div>
            <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">DOM Primitives</h4>
            <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                <li><code>CustomElementRegistry</code> (Standard/Polyfilled)</li>
                <li><code>CustomAttributeRegistry</code></li>
                <li><code>CustomCommentRegistry</code></li>
                <li><code>CustomTextNodeRegistry</code></li>
            </ul>
        </div>
        <div>
            <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">Parsing Engine</h4>
            <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                <li><code>CustomAttributeParserRegistry</code></li>
                <li><code>CustomTextNodeParserRegistry</code></li>
                <li><code>CustomPathExpressionParserRegistry</code></li>
                <li><code>CustomCommentParserRegistry</code></li>
            </ul>
        </div>
        <div>
            <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">Logic & Data</h4>
            <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                <li><code>CustomContextRegistry</code></li>
                <li><code>CustomStoreRegistry</code></li>
                <li><code>CustomEventRegistry</code></li>
                <li><code>HTMLRegistry</code> (Injectors)</li>
            </ul>
        </div>
    </div>

    <h3>Userland Examples</h3>
    <p>You can define your own registries for application-specific needs:</p>

    {% highlight "javascript" %}
import { CustomRegistry } from 'web-registries';

// 1. Define the Registry Class
class IconRegistry extends CustomRegistry {
  localName = 'icons'; // Used for debugging/identification

  // Implement the abstract 'define' method
  define(name, svgContent) {
    this.set(name, svgContent);
  }
}

// 2. Create a Global Registry
const globalIcons = new IconRegistry();
globalIcons.define('menu', '<svg viewBox="0 0 24 24">...</svg>');
globalIcons.define('close', '<svg viewBox="0 0 24 24">...</svg>');

// 3. Create a Scoped Registry (e.g., for a specific Admin module)
const adminIcons = new IconRegistry({ 
  extends: [globalIcons] 
});

// Override 'menu' only for this scope
adminIcons.define('menu', '<svg viewBox="0 0 24 24">...<!-- Admin Menu --></svg>');

// 4. Usage
adminIcons.get('menu');  // Returns Admin Menu (Scoped override)
adminIcons.get('close'); // Returns Global Close (Inherited)
    {% endhighlight %}
    {% endif %}

    {% if project.id == 'webcontexts' %}
    <h3>The Protocol</h3>
    <p>
        <strong>Web Contexts</strong> brings a robust, Dependency Injection-based context system to the HTML platform. 
        It allows data and services to be provided hierarchically down the DOM tree, available to any component that requests them.
    </p>

    <h3>Key Use Cases</h3>
    <ul>
        <li><strong>State Management:</strong> Provide reactive state stores (Redux, Signals) to a subtree of components.</li>
        <li><strong>Theming:</strong> Cascade design tokens or theme definitions without passing props through every layer.</li>
        <li><strong>Service Injection:</strong> Make API clients, loggers, or authentication services available to declarative widgets.</li>
    </ul>

    <div class="comparison-block" style="background: rgba(99, 102, 241, 0.1); padding: 1.5rem; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2); margin: 2rem 0;">
        <h4 style="margin-top: 0; color: var(--color-primary);">Current Standardization vs. Web Contexts</h4>
        
        <p><strong>The Current Standard (Community Protocol):</strong> Relies on <em>Events</em> (<code>context-request</code>). A consumer dispatches an event, which bubbles up until a generic <code>context-provider</code> element catches it.</p>
        
        <p><strong>The Limitation:</strong> To provide context to a list of elements (e.g., in a loop), you must wrap them in a parent provider element.</p>
        {% highlight "html" %}
<!-- Wrapper required for context -->
<context-provider>
   <my-item>...</my-item>
   <my-item>...</my-item>
</context-provider>
        {% endhighlight %}
        <p><em>This wrapper can break CSS layouts (Grid/Flex) and complicate DOM structure.</em></p>

        <hr style="border: 0; border-top: 1px solid rgba(99, 102, 241, 0.2); margin: 1rem 0;">

        {% highlight "html" %}
<!-- Virtual Scope: No wrapper element rendered -->
<!-- scope: theme-context -->
   <my-item>...</my-item>
   <my-item>...</my-item>
        {% endhighlight %}
        <p><strong>The Result:</strong> Multiple elements receive the single context <em>without</em> a physical DOM parent, maintaining your clean layout.</p>
    </div>

    <h3>Try It Out</h3>
    <p>
        This protocol is fully implemented and available for use today. 
        Check out the reference implementation in the <strong><a href="/projects/webplugs/">Web Plugs</a></strong> collection.
    </p>
    {% endif %}

    {% if project.id == 'webtokens' %}
    <h3>The Concept</h3>
    <p>
        <strong>Web Tokens</strong> represents a collection of advanced parsing technologies that allow developers to imbue standard DOM text nodes and attributes with custom behavior. 
        Where standard HTML is static, Tokens make the text itself alive.
    </p>

    <h3>Components</h3>
    <ul>
        <li><strong>Custom Text Nodes:</strong> Define behaviors for specific text patterns within the DOM.</li>
        <li><strong>Custom Text Node Parsers:</strong> The engine that scans and upgrades text nodes into functional run-time objects.</li>
        <li><strong>Web Path Parsers:</strong> Registries for resolving complex data paths (like XPath or JSONPath) directly in your templates.</li>
        <li><strong>Web Attribute Parsers:</strong> Enable custom syntax within attributes (e.g., <code>{{ double_curly }}</code>) to trigger dynamic updates.</li>
    </ul>
    {% endif %}

    {% if project.id == 'webdirectives' %}
    <h3>The Concept</h3>
    <p>
        <strong>Web Directives</strong> provides a unified system for control flow and logic in HTML. 
        It combines standard structural directives (loops, conditionals) with invisible "Comment Directives" and powerful "Template Directives".
    </p>

    <h3>Three Pillars</h3>
    <ul>
        <li><strong>Structural Directives:</strong> Standard attributes (like <code>*if</code> or <code>*for</code>) for manipulating DOM layout.</li>
        <li><strong>Comment Directives:</strong> Use HTML comments to attach logic without extra wrapper elements. Perfect for "ghost" behaviors (formerly Web Figments).</li>
        <li><strong>Template Directives:</strong> Advanced extensions for the <code>&lt;template&gt;</code> element to control instantiation and projection.</li>
    </ul>

    <h3>Why Comment Directives?</h3>
    <p>
        Sometimes you need logic (like a conditional render) but you don't want a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> wrapper breaking your CSS grid or Flexbox layout. 
        Comment directives allow you to anchor this logic to invisible markers in the DOM.
    </p>
    {% endif %}

    <div class="action-area">
        <a href="/" class="btn-back">
            &larr; Back to Home
        </a>
    </div>
</article>
