---
pagination:
    data: projects
    size: 1
    alias: project
permalink: "projects/{{ project.id }}/"
layout: base.njk
mainClass: "project-page-container"
eleventyComputed:
    title: "Web Everything - {{ project.name }}"
---

{% from "project-status.njk" import projectStatus %}

<div class="project-detail-header">
    <div class="project-detail-icon">
        {% if project.isSvg %}
            <img src="{{ project.icon }}" alt="{{ project.name }} icon" width="64" height="64">
        {% else %}
            {{ project.icon }}
        {% endif %}
    </div>
    <h1 class="project-detail-title">{{ project.name }}</h1>
    <p class="project-detail-desc">{{ project.description | safe }}</p>
    
    <div class="project-detail-status">
        <!-- Status Link -->
        <a href="/project-lifecycle/" class="status-lifecycle-link" aria-label="Learn about the project lifestyle stages">
            {{ projectStatus(project.status) }}
        </a>
    </div>
</div>

<div class="project-layout">
    <aside class="project-sidebar">
        <div class="toc-container">
            <h3 id="table-of-contents">Table of Contents</h3>
            <nav class="toc">
                <!-- Tocbot will inject content here -->
            </nav>
        </div>
        <div class="action-area" style="margin-top: 2rem;">
            <a href="/" class="btn-back">
                &larr; Back to Home
            </a>
        </div>
    </aside>

    <div class="project-body">
    {% if project.id == 'webinjectors' %}
        <section id="concept" class="section-card">
            <h3 id="the-concept">The Concept</h3>
            <p>
                <strong>Web Injectors</strong> introduces a first-class language construct related to managing dependency injection and scope flow directly in TypeScript/JavaScript.
                It moves beyond "Import Maps" by allowing dynamic, hierarchical, and domain-based resolution of resources.
            </p>
        </section>

        <section id="syntax" class="section-card">
            <h3 id="core-syntax">Core Syntax</h3>
            <ul>
                <li><code>injector</code>: Declares a new dependency container. Similar to a <code>namespace</code> or <code>module</code> but specifically for dependency resolution.</li>
                <li><code>provide</code>: Exposes values from an injector to a specific domain or globally.</li>
                <li><code>consume</code>: Injects values from a specific domain into the current scope.</li>
                <li><code>domain</code>: A string identifier (e.g., <code>'@app/core'</code>). <strong>This is the contract.</strong> It acts as a universal namespace that prevents naming collisions (e.g., <code>@auth/session</code> vs <code>@analytics/session</code>) and decouples the interface from the implementation.</li>
            </ul>
        </section>

        <section id="deep-dive" class="section-card">
            <h3 id="deep-dive-syntax-usage">Deep Dive: Syntax & Usage</h3>

            <h4 id="1-basic-injector-definition">1. Basic Injector Definition</h4>
            <p>An <code>injector</code> is a block that encapsulates resources. You can export it just like a class or variable.</p>
            {% highlight "typescript" %}
// definitions.ts
export injector definitions {
    // Define resources inside the injector
    const Resource = 100;
    
    // Expose them to the outside world
    provide { Resource };
}
            {% endhighlight %}

            <h4 id="2-consuming-dependencies">2. Consuming Dependencies</h4>
            <p>Consumers request resources from a specific "domain" string. This decouples the consumer from the concrete implementation file.</p>
            {% highlight "typescript" %}
// consumer.ts
// We don't import from 'definitions.ts'. 
// We consume from the abstract domain '@definitions'.
consume { Resource } of '@definitions';

const r: number = Resource; // 'Resource' is now available in this scope
            {% endhighlight %}

            <h4 id="3-composition-wiring">3. Composition & Wiring</h4>
            <p>The "Main" or "Root" of the application wires the concrete implementation (<code>definitions</code>) to the abstract domain (<code>@definitions</code>).</p>
            {% highlight "typescript" %}
// main.ts
import { definitions } from "./definitions";

export injector main {
    // 1. Contextualize: Map the concrete 'definitions' injector 
    //    to the abstract identifier '@definitions'.
    provide * to '@definitions' from definitions;

    // 2. Include the consumer code into this execution context
    provide * from "./consumer";
}
            {% endhighlight %}

            <h4 id="4-fallback-providers">4. Fallback Providers (Polyfills)</h4>
            <p>
                Injectors can provide fallback implementations that are only used if the dependency hasn't been provided by an ancestor.
                This allows libraries to be self-sufficient while remaining extensible.
            </p>
            {% highlight "typescript" %}
injector Component extends import.injector {
    // Will be ignored if 'Logger' exists in the parent scope
    provide fallback { Logger } from './console-logger';
}
            {% endhighlight %}
        </section>

        <section id="case-study" class="section-card">
            <h3 id="case-study-the-hollow-calendar-widget">Case Study: The "Hollow" Calendar Widget</h3>
            <p>
                Modern UI libraries (like <code>react-calendar</code> or <code>mui-datepicker</code>) are often monolithic bundles containing date math, formatting logic, positioning engines, and styling.
                With <strong>Web Injectors</strong>, we can build a "hollow" widget that delegates all complexity to injected protocols.
            </p>

            <h4 id="deconstructing-the-calendar">Deconstructing the Calendar</h4>
            <p>A rich calendar widget actually encapsulates several distinct domains:</p>
            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                <div class="content-box" style="padding: 1rem;">
                    <strong>Date Logic</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Adding months, calculating start-of-week, validation.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/core</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Localization</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Formatting "MMMM YYYY", day names "Mon/Tue".</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/fmt</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Positioning</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Floating element anchor, collision detection.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/floating</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Icons</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Chevron Left/Right, Calendar icon.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/icons</code>
                </div>
            </div>

            <h4 id="the-widget-implementation">The Widget Implementation</h4>
            <p>Notice how the component below contains <strong>zero</strong> implementation logic. It is purely an orchestrator.</p>

            {% highlight "typescript" %}
// components/calendar.ts
// -----------------------
// 1. Declare dependencies on abstract domains
consume { addMonths, startOfMonth, getDaysInMonth } of '@date/core';
consume { format }                                  of '@date/fmt';
consume { useFloating, offset, flip }               of '@ui/floating';
consume { ChevronLeft, ChevronRight }               of '@ui/icons';

export class HollowCalendar extends HTMLElement {
  connectedCallback() {
      this.render();
  }

  render() {
      // 2. Use the injected 'format' function
      // The widget doesn't know if this is using Intl, date-fns, or moment.
      const title = format(new Date(), 'MMMM yyyy');

      // 3. Use the injected 'Chevron' icons
      // The widget doesn't know if these are SVGs, FontAwesome, or Images.
      this.innerHTML = `
        <header>
           <button>${ChevronLeft}</button>
           <span>${title}</span>
           <button>${ChevronRight}</button>
        </header>
        <div class="grid">
           <!-- Days rendered here using injected math -->
        </div>
      `;
  }
}
            {% endhighlight %}

            <h4 id="the-wiring-application-root">The Wiring (Application Root)</h4>
            <p>This is where we decide <em>how</em> the calendar behaves in this specific application.</p>

            {% highlight "typescript" %}
// app.ts
import { DateFnsAdapter } from "./adapters/date-fns";
import { FloatingUIDOM } from "./adapters/floating-ui";
import { FontAwesomeIcons } from "./theme/fa-icons";

// Create the unified environment
export injector AppEnvironment {
    // Bind specific libraries to the abstract domains
    provide * to '@date/core'     from DateFnsAdapter;
    provide * to '@date/fmt'      from DateFnsAdapter;
    provide * to '@ui/floating'   from FloatingUIDOM;
    provide * to '@ui/icons'      from FontAwesomeIcons;
}

// Now render the app
// <hollow-calendar> will automatically receive the provided implementations.
            {% endhighlight %}
        </section>

        <section id="why" class="section-card">
            <h3 id="why-this-matters">Why This Matters?</h3>
            <p>
                This pattern allows for true <strong>Inversion of Control</strong> at the language level. 
                Your <code>consumer.ts</code> never needs to know where <code>Resource</code> comes from, or even if it was mocked for testing. 
                The <code>main</code> injector acts as the composition root, binding <code>RealService</code> to <code>@service</code> in production, or <code>MockService</code> to <code>@service</code> in tests.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webbehaviors' %}
        <section id="concept" class="section-card">
            <h3 id="the-concept">The Concept</h3>
            <p>
                <strong>Web Behaviors</strong> enable developers to attach rich functionality to any DOM element using custom attributes.
                This brings the "Decorator" pattern to HTML, allowing for powerful composition without the need for component wrappers. Web Behaviors are registered to the <code>CustomAttributeRegistry</code>.
            </p>
        </section>

        <section id="case-study" class="section-card">
            <h3 id="case-study-router-links">Case Study: Router Links</h3>
            <p>
                In many SPAs, you need a special component (like <code>&lt;Link&gt;</code> or <code>&lt;router-link&gt;</code>) to handle navigation without reloading the page.
                This forces you to replace standard <code>&lt;a&gt;</code> tags with framework-specific components that might struggle to emulate all native behavior (accessibility, drag-to-tab, context menus).
            </p>
            <p><strong>With Web Behaviors:</strong> You simply enhance the standard anchor tag.</p>

            {% highlight "html" %}
<!-- Standard HTML, upgraded behavior -->
<a href="/profile" history-link>My Profile</a>

<!-- Composition: A button that acts as a link -->
<button history-link="/dashboard">Go to Dashboard</button>
            {% endhighlight %}

            <div class="comparison-block" style="background: rgba(99, 102, 241, 0.05); padding: 1.25rem; border-radius: 8px; border-left: 4px solid var(--color-primary); margin: 2rem 0;">
                <h4 id="note-vs-customized-built-in-elements" style="margin-top: 0; color: var(--color-primary); font-size: 1rem;">Note: vs Customized Built-in Elements</h4>
                <p style="margin-bottom: 0.5rem; font-size: 0.95rem;">
                    The Web Components standard allows extending native elements using the <code>is</code> attribute (e.g., <code>&lt;button is="my-button"&gt;</code>).
                </p>
                <p style="margin-bottom: 0; font-size: 0.95rem;">
                    <strong>The limitation?</strong> An element can only have <em>one</em> <code>is</code> value (single inheritance). 
                    <strong>Web Behaviors</strong> allow for <strong style="color: var(--color-primary);">composition</strong>, meaning you can attach as many independent functional attributes as needed to a single element.
                </p>
            </div>
        </section>

        <section id="implementation" class="section-card">
            <h3 id="the-implementation">The Implementation</h3>
            <p>
                Following the reference implementation in <strong>Web Plugs</strong>, a Behavior is a class that receives the <code>ownerElement</code> and uses standard lifecycle hooks.
            </p>

            {% highlight "typescript" %}
import { CustomAttribute } from '@web-plugs/web-behaviors';

class HistoryLink extends CustomAttribute {
    // Observe changes to the 'href' attribute
    static get observedAttributes() { return ['href']; }

    connectedCallback() {
        // Enhance the element with a click listener
        this.ownerElement.addEventListener('click', this.navigate);
    }
    
    disconnectedCallback() {
        this.ownerElement.removeEventListener('click', this.navigate);
    }

    navigate = (e) => {
        // Prevent full page reload
        e.preventDefault();
        
        // Determine URL from attribute value OR element's href
        const url = this.value || this.ownerElement.getAttribute('href');
        
        // Push to History API
        window.history.pushState(null, '', url);
    }
}

// Register the behavior
customAttributes.define('history-link', HistoryLink);
            {% endhighlight %}
        </section>

        <section id="specs" class="section-card">
            <h3 id="standard-specification-draft">Standard Specification (Draft)</h3>
            <p>To formalize Web Behaviors as a platform standard, the following interfaces and augmentations would be introduced to the HTML specification.</p>

            <h4 id="1-new-class-customattribute">1. new class CustomAttribute</h4>
            <p>
                The base class for all behaviors. It mirrors the lifecycle of Custom Elements but is scoped to an attribute.
                <strong>Requirement:</strong> Attribute names must contain a hyphen (e.g., <code>my-attr</code>) to avoid collision with standard HTML attributes.
            </p>
            {% highlight "typescript" %}
interface CustomAttribute {
    // Properties
    readonly ownerElement: Element;
    readonly name: string;
    readonly value: string;

    // Lifecycle Callbacks
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    attributeChangedCallback?(
        name: string, 
        oldValue: string | null, 
        newValue: string | null
    ): void;

    // Static
    static readonly observedAttributes?: string[];
}
            {% endhighlight %}

            <h4 id="2-new-interface-customattributeregistry">2. new interface CustomAttributeRegistry</h4>
            <p>The global registry handling behavior definitions, similar to <code>customElements</code>.</p>
            {% highlight "typescript" %}
interface CustomAttributeRegistry {
    define(name: string, constructor: CustomAttributeConstructor, options?: any): void;
    get(name: string): CustomAttributeConstructor | undefined;
    upgrade(root: Node): void;
    whenDefined(name: string): Promise<CustomAttributeConstructor>;
}
            {% endhighlight %}

            <h4 id="3-extensions-to-window">3. Extensions to Window</h4>
            <p>Exposing the registry on the global object.</p>
            {% highlight "typescript" %}
interface Window {
    readonly customAttributes: CustomAttributeRegistry;
}
            {% endhighlight %}

            <h4 id="4-ecosystem-dependencies">4. Ecosystem Dependencies</h4>
            <div class="content-box">
                <ul style="margin: 0; padding-left: 1.25rem;">
                    <li><strong>Web Registries:</strong> The <code>CustomAttributeRegistry</code> must implement the unified Registry interface defined by the Web Registries spec.</li>
                    <li><strong>DOM Mutation API:</strong> The polyfill implementation (Web Plug) relies on <code>MutationObserver</code> to detect attribute additions/removals. A native browser implementation would optimize this event loop internally.</li>
                </ul>
            </div>
        </section>

        <section id="examples" class="section-card">
            <h3 id="userland-examples">Userland Examples</h3>
            <p>
                Behaviors are exceptionally versatile. Here is a showcase of potential use cases ranging from UI interactions to data management.
            </p>

            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-top: 1.5rem; margin-bottom: 2rem;">
                
                <!-- UI Interactions -->
                <div class="content-box">
                    <h4 id="ui-interactions" style="color: var(--color-primary); margin: 0 0 0.5rem 0;">UI Interactions</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>click-outside</code>:
                            <br><span>Detects clicks outside the element (useful for modals/dropdowns).</span>
                        </li>
                        <li>
                            <code>ripple-effect</code>:
                            <br><span>Material Design-style ink ripple on click.</span>
                        </li>
                        <li>
                            <code>draggable-item</code>:
                            <br><span>Makes an element draggable within a container (Kanban style).</span>
                        </li>
                        <li>
                            <code>scroll-lock</code>:
                            <br><span>Prevents scroll on body when this element is active/open.</span>
                        </li>
                    </ul>
                </div>

                <!-- Data & Forms -->
                <div class="content-box">
                    <h4 id="forms-data" style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Forms & Data</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>bind-value="prop"</code>:
                            <br><span>Two-way data binding between an input and a state property.</span>
                        </li>
                        <li>
                            <code>validate-email</code>:
                            <br><span>Adds custom validity checks to an input field.</span>
                        </li>
                        <li>
                            <code>auto-grow</code>:
                            <br><span>Automatically resizes a <code>&lt;textarea&gt;</code> based on content height.</span>
                        </li>
                        <li>
                            <code>copy-to-clipboard</code>:
                            <br><span>Copies the element's text content on click.</span>
                        </li>
                    </ul>
                </div>

                <!-- Visibility & Layout -->
                <div class="content-box">
                    <h4 id="visibility-lifecycle" style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Visibility & Lifecycle</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>lazy-load</code>:
                            <br><span>Only loads content (image/iframe) when element enters viewport.</span>
                        </li>
                        <li>
                            <code>animate-on-scroll</code>:
                            <br><span>Triggers a CSS animation class when scrolled into view.</span>
                        </li>
                        <li>
                            <code>hide-element="condition"</code>:
                            <br><span>Toggles <code>display: none</code> based on a reactive state.</span>
                        </li>
                        <li>
                            <code>pop-element</code>:
                            <br><span>Manages <code>popover</code> API behavior with enhanced positioning.</span>
                        </li>
                    </ul>
                </div>

                <!-- Advanced Logic -->
                <div class="content-box">
                    <h4 id="advanced-patterns" style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Advanced Patterns</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>provide-store="key"</code>:
                            <br><span>Exposes a store instance to the subtree context.</span>
                        </li>
                        <li>
                            <code>track-analytics="event"</code>:
                            <br><span>Sends a telemetry event when the user interacts with the element.</span>
                        </li>
                        <li>
                            <code>composite-widget</code>:
                            <br><span>Orchestrates multiple child behaviors into a single logical unit.</span>
                        </li>
                    </ul>
                </div>

            </div>
        </section>

        <section id="why" class="section-card">
            <h3 id="why-this-matters">Why This Matters?</h3>
            <ul>
                <li><strong>Styling Preserved:</strong> No extra <code>&lt;div&gt;</code> wrappers breaking Flexbox or Grid layouts.</li>
                <li><strong>Accessibility:</strong> You enhance native elements definition (progressive enhancement) rather than replacing them with semantically ambiguous custom tags.</li>
                <li><strong>Composition:</strong> An element can have multiple behaviors simultaneously: <br><code>&lt;input validate-email track-change auto-save&gt;</code>.</li>
            </ul>
        </section>
    {% endif %}

    {% if project.id == 'webregistries' %}
        <section id="protocol" class="section-card">
            <h3 id="the-protocol">The Protocol</h3>
            <p>
                <strong>Web Registries</strong> define a standard interface for creating scoped, hierarchical registries on the web platform. 
                Where standard <code>Map</code> or <code>CustomElementRegistry</code> are flat and global, Web Registries are designed for **inheritance** and **scoping**.
            </p>
        </section>

        <section id="features" class="section-card">
            <h3 id="key-features">Key Features</h3>
            <ul>
                <li><strong>Standard Interface:</strong> All registries implement a common <code>get</code>, <code>has</code>, <code>set</code> (via <code>define</code>) API.</li>
                <li><strong>Inheritance:</strong> A registry can extend one or more parent registries. Lookups traverse the chain automatically.</li>
                <li><strong>Scoping:</strong> Enables different parts of an application to have different definitions for the same key (e.g., scoping icons or formatters to a specific routed view).</li>
            </ul>
        </section>

        <section id="standards" class="section-card">
            <h3 id="proposed-standards">Proposed Standards</h3>
            <p>The <strong>Web Everything</strong> platform proposes standardizing registries for nearly every aspect of the DOM, allowing for unprecedented extensibility:</p>
            
            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
                <div>
                    <h4 id="dom-primitives" style="color: var(--color-primary); margin-bottom: 0.5rem;">DOM Primitives</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomElementRegistry</code> (Standard/Polyfilled)</li>
                        <li><code>CustomAttributeRegistry</code></li>
                        <li><code>CustomCommentRegistry</code></li>
                        <li><code>CustomTextNodeRegistry</code></li>
                    </ul>
                </div>
                <div>
                    <h4 id="parsing-engine" style="color: var(--color-primary); margin-bottom: 0.5rem;">Parsing Engine</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomAttributeParserRegistry</code></li>
                        <li><code>CustomTextNodeParserRegistry</code></li>
                        <li><code>CustomPathExpressionParserRegistry</code></li>
                        <li><code>CustomCommentParserRegistry</code></li>
                    </ul>
                </div>
                <div>
                    <h4 id="logic-data" style="color: var(--color-primary); margin-bottom: 0.5rem;">Logic & Data</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomContextRegistry</code></li>
                        <li><code>CustomStoreRegistry</code></li>
                        <li><code>CustomEventRegistry</code></li>
                        <li><code>HTMLRegistry</code> (Injectors)</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="examples" class="section-card">
            <h3 id="userland-examples">Userland Examples</h3>
            
            <h4 id="example-1-icon-system">Example 1: Icon System</h4>
            <p>You can define your own registries for application-specific needs. Here is how you might build an Icon Registry that supports overriding icons in different contexts.</p>

            {% highlight "javascript" %}
import { CustomRegistry } from '@web-plugs/web-registries';

// 1. Define the Registry Class
class IconRegistry extends CustomRegistry {
  localName = 'icons'; // Used for debugging/identification
}

// 2. Create the registries
const globalIcons = new IconRegistry();
globalIcons.define('menu', '<svg viewBox="0 0 24 24">...</svg>');
globalIcons.define('close', '<svg viewBox="0 0 24 24">...</svg>');

// 3. Create a Scoped Registry (e.g., for a specific Admin module)
// It inherits everything from globalIcons, but can shadow them
const adminIcons = new IconRegistry({ 
  extends: [globalIcons] 
});

// Override 'menu' only for this scope
adminIcons.define('menu', '<svg viewBox="0 0 24 24">...<!-- Admin Menu --></svg>');
            {% endhighlight %}

            <p><strong>Connecting to Components:</strong> A theoretical <code>&lt;ui-icon&gt;</code> component illustrating how to consume the registry.</p>

            {% highlight "html" %}
<script type="module">
  // Hypothetical component that consumes our IconRegistry
  class UIIcon extends HTMLElement {
    connectedCallback() {
      // In a real app, 'adminIcons' might be provided via Context or Dependency Injection
      // For this POC demonstration, we import it directly.
      const registry = this.hasAttribute('admin') ? adminIcons : globalIcons;
      
      const iconName = this.getAttribute('name');
      if (registry.has(iconName)) {
         this.innerHTML = registry.get(iconName);
      }
    }
  }
  customElements.define('ui-icon', UIIcon);
</script>

<!-- Usage -->
<ui-icon name="menu"></ui-icon>         <!-- Renders standard menu -->
<ui-icon name="menu" admin></ui-icon>   <!-- Renders admin menu (via scoped registry) -->
            {% endhighlight %}
        </section>
    {% endif %}

    {% if project.id == 'webcontexts' %}
        <section id="protocol" class="section-card">
            <h3 id="the-protocol">The Protocol</h3>
            <p>
                <strong>Web Contexts</strong> brings a robust, Dependency Injection-based context system to the HTML platform. 
                It allows data and services to be provided hierarchically down the DOM tree, available to any component that requests them.
            </p>
        </section>

        <section id="use-cases" class="section-card">
            <h3 id="key-use-cases">Key Use Cases</h3>
            <ul>
                <li><strong>State Management:</strong> Provide reactive state stores (Redux, Signals) to a subtree of components.</li>
                <li><strong>Theming:</strong> Cascade design tokens or theme definitions without passing props through every layer.</li>
                <li><strong>Service Injection:</strong> Make API clients, loggers, or authentication services available to declarative widgets.</li>
            </ul>
        </section>

        <section id="comparison" class="section-card">
            <div class="comparison-block" style="background: rgba(99, 102, 241, 0.1); padding: 1.5rem; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2); margin: 2rem 0;">
                <h4 id="current-standardization-vs-web-contexts" style="margin-top: 0; color: var(--color-primary);">Current Standardization vs. Web Contexts</h4>
                
                <p><strong>The Current Standard (Community Protocol):</strong> Relies on <em>Events</em> (<code>context-request</code>). A consumer dispatches an event, which bubbles up until a generic <code>context-provider</code> element catches it.</p>
                
                <p><strong>The Limitation:</strong> To provide context to a list of elements (e.g., in a loop), you must wrap them in a parent provider element.</p>
                {% highlight "html" %}
<!-- Wrapper required for context -->
<context-provider>
   <my-item>...</my-item>
   <my-item>...</my-item>
</context-provider>
                {% endhighlight %}
                <p><em>This wrapper can break CSS layouts (Grid/Flex) and complicate DOM structure.</em></p>

                <hr style="border: 0; border-top: 1px solid rgba(99, 102, 241, 0.2); margin: 1rem 0;">

                {% highlight "html" %}
<!-- Virtual Scope: No wrapper element rendered -->
<!-- scope: theme-context -->
   <my-item>...</my-item>
   <my-item>...</my-item>
                {% endhighlight %}
                <p><strong>The Result:</strong> Multiple elements receive the single context <em>without</em> a physical DOM parent, maintaining your clean layout.</p>
            </div>
        </section>

        <section id="try-it" class="section-card">
            <h3 id="try-it-out">Try It Out</h3>
            <p>
                This protocol is fully implemented and available for use today. 
                Check out the reference implementation in the <strong><a href="/projects/webplugs/">Web Plugs</a></strong> collection.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webtokens' %}
        <section id="concept" class="section-card">
            <h3 id="the-concept">The Concept</h3>
            <p>
                <strong>Web Tokens</strong> represents a collection of advanced parsing technologies that allow developers to imbue standard DOM text nodes and attributes with custom behavior. 
                Where standard HTML is static, Tokens make the text itself alive.
            </p>
        </section>

        <section id="components" class="section-card">
            <h3 id="components">Components</h3>
            <ul>
                <li><strong>Custom Text Nodes:</strong> Define behaviors for specific text patterns within the DOM.</li>
                <li><strong>Custom Text Node Parsers:</strong> The engine that scans and upgrades text nodes into functional run-time objects.</li>
                <li><strong>Web Path Parsers:</strong> Registries for resolving complex data paths (like XPath or JSONPath) directly in your templates.</li>
                <li><strong>Web Attribute Parsers:</strong> Enable custom syntax within attributes (e.g., <code>{{ double_curly }}</code>) to trigger dynamic updates.</li>
            </ul>
        </section>
    {% endif %}

    {% if project.id == 'webdirectives' %}
        <section id="concept" class="section-card">
            <h3 id="the-concept">The Concept</h3>
            <p>
                <strong>Web Directives</strong> provides a unified system for control flow and logic in HTML. 
                It combines standard structural directives (loops, conditionals) with invisible "Comment Directives" and powerful "Template Directives".
            </p>
        </section>

        <section id="pillars" class="section-card">
            <h3 id="three-pillars">Three Pillars</h3>
            <ul>
                <li><strong>Structural Directives:</strong> Standard attributes (like <code>*if</code> or <code>*for</code>) for manipulating DOM layout.</li>
                <li><strong>Comment Directives:</strong> Use HTML comments to attach logic without extra wrapper elements. Perfect for "ghost" behaviors (formerly Web Figments).</li>
                <li><strong>Template Directives:</strong> Advanced extensions for the <code>&lt;template&gt;</code> element to control instantiation and projection.</li>
            </ul>
        </section>

        <section id="why" class="section-card">
            <h3 id="why-comment-directives">Why Comment Directives?</h3>
            <p>
                Sometimes you need logic (like a conditional render) but you don't want a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> wrapper breaking your CSS grid or Flexbox layout. 
                Comment directives allow you to anchor this logic to invisible markers in the DOM.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webplugs' %}
        <section id="overview" class="section-card">
            <h3 id="overview">Overview</h3>
            <p>
                <strong>Web Plugs</strong> is the foundational layer of the Web Everything platform. 
                It provides the necessary polyfills and patches to the native browser environment to enable the advanced features required by downstream projects.
            </p>
            <p>
                Each "Plug" is a modular slice of functionality. They are designed to depend on each other hierarchically, allowing you to only load what you need.
            </p>

            <div class="mt-6 p-4 bg-gray-50 rounded-lg border border-gray-100">
                <h4 id="plug-types" class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-3">Plug Types</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                    <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 mr-2 border border-blue-200">New Primitive</span>
                        <span class="text-gray-600 text-xs">Abstract base classes</span>
                    </div>
                    <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 mr-2 border border-emerald-200">New Global</span>
                        <span class="text-gray-600 text-xs">New window objects</span>
                    </div>
                     <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 mr-2 border border-amber-200">Patch</span>
                        <span class="text-gray-600 text-xs">Modifies native API</span>
                    </div>
                </div>
            </div>
        </section>

        <section id="core-patches" class="section-card">
            <h3 id="core-dom-patches">Core DOM Patches</h3>
            <p class="mb-4">These patches are modularized to allow for tree-shaking and specific feature usage. They can be imported individually or as part of the full suite.</p>

            <h4 id="web-injectors-patches" class="mt-8 mb-4 text-gray-800 border-b border-gray-200 pb-2">Web Injectors Patches</h4>
            <p class="mb-4 text-sm text-gray-600"><strong>Module:</strong> <code>plateau/src/plugs/web-injectors</code></p>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">Node (Injector Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Replaces the global <code>Node</code> constructor to capture the <code>creationInjector</code> context. It also mixes in the Injection API.</p>
                <strong>Adds API:</strong>
                <ul class="list-disc ml-5 mb-2 text-sm text-gray-600">
                    <li><code>getClosestInjector()</code></li>
                    <li><code>getOwnInjector()</code></li>
                    <li><code>createContext()</code> / <code>getContext()</code></li>
                </ul>
            </div>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">Element (Injector Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Intersects <code>innerHTML</code> to propagate the current injector scope to newly created nodes.</p>
            </div>

            <h4 id="web-components-patches" class="mt-8 mb-4 text-gray-800 border-b border-gray-200 pb-2">Web Components Patches</h4>
            <p class="mb-4 text-sm text-gray-600"><strong>Module:</strong> <code>plateau/src/plugs/web-components</code></p>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">Node (Component Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Patches <code>cloneNode</code> to ensure Custom Elements and enhanced nodes are correctly reconstructed during cloning (preserving prototype and options).</p>
            </div>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">Element (Component Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p> Patriales DOM insertion methods to "lazy upgrade" definitions when elements connect to the DOM.</p>
                <strong>Patched Methods:</strong>
                <ul class="list-disc ml-5 mb-2 text-sm text-gray-600">
                    <li><code>innerHTML</code></li>
                    <li><code>append</code>, <code>prepend</code>, <code>after</code>, <code>before</code></li>
                    <li><code>replaceChildren</code>, <code>replaceWith</code></li>
                </ul>
            </div>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">HTMLElement (Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Wraps native constructors to enable the dynamic registry system.</p>
            </div>

            <div class="mb-6">
                <h5 class="font-bold text-gray-800">Document (Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Patches <code>createElement</code> to apply correct prototypes.</p>
            </div>

             <div class="mb-6">
                <h5 class="font-bold text-gray-800">DocumentFragment (Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Fixes <code>ownerTemplate</code> properties.</p>
            </div>

             <div class="mb-6">
                <h5 class="font-bold text-gray-800">HTMLTemplateElement (Patch)</h5>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Patches the <code>content</code> getter.</p>
            </div>

        </section>

        <section id="registry-plugs" class="section-card">
            <h3 id="web-registries-plugs">Web Registries Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webregistries/">Web Registries</a></p>

            <div>
                <h4 id="customregistry">CustomRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>The abstract base class for all scoped registries. It standardizes the API for storing and retrieving definitions, supporting inheritance from parent registries.</p>
                
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomRegistry<Definition, Key> {
    abstract readonly localName: string;
    
    // Core Registry API
    define(name: Key, definition: Definition): void;
    get(name: Key): Definition | undefined;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="htmlregistry">HTMLRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>
                    A specialized abstract registry for storing constructors that are bound to DOM nodes. 
                    It handles the complexity of "Upgrading" and "Downgrading" nodes when definitions are added or removed.
                </p>

                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface HTMLRegistry<Definition, DefType> extends CustomRegistry<
    Definition, 
    string
> {
    abstract readonly localName: string;

    // Node Lifecycle
    abstract upgrade(node: Node): void;
    abstract downgrade(node: Node): void;
    
    // Reverse Lookup
    getLocalNameOf(constructor: DefType): string | undefined;
}
                {% endhighlight %}
            </div>
            
            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customelementregistry-patch">CustomElementRegistry (Patch)</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch / Extension</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Replaces the native <code>window.customElements</code> with a version that extends <code>HTMLRegistry</code>. 
                    This keeps the native API compatible while unlocking the features of <strong>Web Registries</strong> (polyfilled scoping and inheritance).
                </p>

                <strong>Interface:</strong>
                 {% highlight "typescript" %}
class CustomElementRegistry extends HTMLRegistry<
    ElementDefinition, 
    ImplementedElement
> {
    // Standard CustomElementRegistry API
    define(
        name: string, 
        constructor: CustomElementConstructor, 
        options?: ElementDefinitionOptions
    ): void;
    get(name: string): CustomElementConstructor | undefined;
    whenDefined(name: string): Promise<CustomElementConstructor>;
    upgrade(root: Node): void;
}
                 {% endhighlight %}
            </div>
        </section>

        <section id="behaviors" class="section-card">
            <h3 id="web-behaviors-plugs">Web Behaviors Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webbehaviors/">Web Behaviors</a></p>

            <div>
                <h4 id="customattributesregistry">CustomAttributesRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Exposes <code>window.customAttributes</code>. It monitors the DOM for attribute changes and facilitates the "Upgrade" of standard attributes into enhanced behaviors.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomAttributesRegistry extends HTMLRegistry<
    AttributeDefinition, 
    ImplementedAttribute
> {
    readonly localName = 'customAttributes';

    // Same behavior as CustomElementRegistry but for attributes
    define(
        name: string, 
        constructor: ImplementedAttribute, 
        options?: CustomAttributesOptions
    ): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customattribute">CustomAttribute</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>
                    The base class for creating behaviors, similar to <code>HTMLElement</code>.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomAttribute {
    // Instance Properties
    readonly ownerElement: Element;
    readonly name: string;
    readonly value: string;
    
    // Lifecycle Callbacks
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    attributeChangedCallback?(
        name: string, 
        oldValue: string | null, 
        newValue: string | null
    ): void;
    
    // Static Configuration
    static readonly observedAttributes?: string[];
    static readonly formAssociated?: boolean;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customattributeparserregistry">CustomAttributeParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Allows defining parsing logic for attribute values.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomAttributeParserRegistry extends CustomRegistry<CustomAttributeParser> {
    readonly localName = 'CustomAttributeParsers';
    define(
        name: string, 
        parser: CustomAttributeParser
    ): void;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="contexts" class="section-card">
            <h3 id="web-contexts-plugs">Web Contexts Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webcontexts/">Web Contexts</a></p>

            <div>
                <h4 id="customcontextregistry">CustomContextRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Exposes <code>window.customContextTypes</code>. It allows registering context definitions that provide data flow deeply to children.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomContextRegistry extends HTMLRegistry<
    ContextDefinition, 
    ImplementedContext
> {
    readonly localName = 'customContextTypes';

    define(name: string, Context: ImplementedContext): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customcontext">CustomContext</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>
                    Base class for defining a context provider.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomContext<ContextValue> {
    // Similar to CustomElement
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    adoptedCallback?(): void;

    // Context Specific
    contextConsumedCallback?(
        callback: (...args: unknown[]) => ContextValue
    ): void;
    static readonly observedContexts?: string[];
}
                {% endhighlight %}
            </div>
        </section>

        <section id="injectors" class="section-card">
            <h3 id="web-injectors-plugs">Web Injectors Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webinjectors/">Web Injectors</a></p>

            <div>
                <h4 id="injectorroot">InjectorRoot</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p>
                    The root container for dependency injection. It handles the map of all active injectors in the DOM tree.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
class InjectorRoot {
    // Retrieval Methods used by resolution algorithm
    static getInjectorRootOf(node: Node): InjectorRoot | undefined;
    static getProviderOf(node: Node, providerName: string): Provider | undefined;
    static getProvidersOf(node: Node): Map<string, Provider>;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="tokens" class="section-card">
            <h3 id="web-tokens-plugs">Web Tokens Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webtokens/">Web Tokens</a></p>

            <div>
                <h4 id="customtextnoderegistry">CustomTextNodeRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Allows defining parsers for text content (e.g., Mustache syntax <code>{{ '{}' }}</code>).</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomTextNodeRegistry extends HTMLRegistry<
    TextNodeDefinition, 
    ImplementedTextNode
> {
    readonly localName = 'customTextNodes';
    define(name: string, TextNode: ImplementedTextNode): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customtextnodeparserregistry">CustomTextNodeParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Manages parsers that can interpret text node content.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomTextNodeParserRegistry extends CustomRegistry<CustomTextNodeParser> {
    readonly localName = 'customTextNodeParsers';
    define(
        name: string, 
        parser: CustomTextNodeParser
    ): void;
}
                {% endhighlight %}
            </div>
            
            <hr class="my-6 border-gray-200">

             <div>
                <h4 id="custompathexpressionparserregistry">CustomPathExpressionParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Registry for path expression parsers.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomPathExpressionParserRegistry extends CustomRegistry<
    CustomPathExpressionParser
> {
    readonly localName = 'customPathExpressionParsers';
    define(
        name: string, 
        parser: CustomPathExpressionParser
    ): void;
    
    // Returns a Consumable that provides the resolved parser
    query(): Consumable<CustomPathExpressionParser>;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

             <div>
                <h4 id="custompathexpressionparser">CustomPathExpressionParser</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Standardizes how strings are parsed into executable paths (e.g. keypaths in bindings).</p>
                 <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomPathExpressionParser {
    abstract parse(text: string): Graph;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="directives" class="section-card">
            <h3 id="web-directives-plugs">Web Directives Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webdirectives/">Web Directives</a></p>

            <div>
                <h4 id="customcommentregistry">CustomCommentRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Enables attaching behavior to comment nodes, useful for structural directives (like `virtual-element`).</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomCommentRegistry extends HTMLRegistry<
    CommentDefinition, 
    ImplementedComment
> {
    readonly localName = 'customComments';
    define(name: string, comment: ImplementedComment): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customcomment">CustomComment</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Base class for enhanced comments.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
class CustomComment extends Comment {
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    optionsChangedCallback?(oldValue: unknown, newValue: unknown): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customcommentparserregistry">CustomCommentParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Parses comment content to identify custom comments.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomCommentParserRegistry extends CustomRegistry<CustomCommentParser> {
    readonly localName = 'customCommentParsers';
    define(
        name: string, 
        parser: CustomCommentParser
    ): void;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="scripting" class="section-card">
            <h3 id="web-scripting-plugs">Web Scripting Plugs</h3>
            <p class="mb-4"><strong>Experimental</strong></p>

             <div>
                <h4 id="customscripttypesregistry">CustomScriptTypesRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Allows defining custom behavior for <code>&lt;script type="..."&gt;</code> tags.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomScriptTypesRegistry extends HTMLRegistry<
    ScriptTypeDefinition, 
    ImplementedCustomScriptType
> {
    readonly localName = 'customScriptTypes';
    define(
        name: string, 
        scriptType: ImplementedCustomScriptType
    ): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4 id="customscripttype">CustomScriptType</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Base class extending <code>HTMLScriptElement</code>.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomScriptType extends HTMLScriptElement {
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    adoptedCallback?(): void;
}
                {% endhighlight %}
            </div>
        </section>

        </section>
    {% endif %}

    {% if project.id == 'webstates' %}
        <section class="intro-section mb-12">
            <h3 id="mission">Mission</h3>
            <p>
                <strong>Web States</strong> standardizes how state is managed, observed, and validated in the browser. 
                By elevating Stores, Signals, and Schemas to first-class primitives, we decouple state logic from UI frameworks.
            </p>
        </section>

        <section id="proposed-states" class="section-card">
            <h3 id="proposed-standards">Proposed Standards</h3>
            <div class="standards-grid">
                {% for state in states %}
                <a href="/states/{{ state.id }}/" class="standard-card">
                    <div class="flex justify-between items-start mb-3">
                        <h4 id="state-{{ state.id }}" class="text-lg font-bold m-0 text-gray-900">{{ state.name }}</h4>
                    </div>
                    <p class="text-gray-600 text-sm leading-relaxed mb-4">{{ state.summary }}</p>
                    <div style="margin-bottom: 1rem;">
                        {{ projectStatus(state.status) }}
                    </div>
                </a>
                {% endfor %}
            </div>
        </section>
    {% endif %}

    {% if project.id == 'webblocks' %}
        <section class="intro-section mb-12">
            <h3 id="mission">Mission</h3>
            <p>The <strong>Web Blocks</strong> project aims to establish a set of standard protocols for interoperable modulesboth visual components and behavioral traits. By focusing on the <em>protocol</em> rather than the implementation, we ensure that parts from different libraries can work together to provide consistent UX and accessibility.</p>
            <p>This initiative defines the "how it works" and "how it communicates" portion of web development, leaving the "how it looks" to the implementer.</p>
        </section>

        <section class="standards-section">
            <h3 id="proposed-standards">Proposed Standards</h3>
            <div class="standards-grid">
                {% for block in blocks %}
                <a href="/blocks/{{ block.id }}/" class="standard-card">
                    <div class="flex justify-between items-start mb-3">
                        <h4 id="block-name" class="text-lg font-bold m-0 text-gray-900">{{ block.name }}</h4>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                            {{ block.type }}
                        </span>
                    </div>
                    <p class="text-gray-600 text-sm leading-relaxed mb-4">{{ block.summary }}</p>
                    <div style="margin-bottom: 1rem;">
                        {{ projectStatus(block.status) }}
                    </div>
                </a>
                {% endfor %}
            </div>
        </section>
    {% endif %}

    {% if project.id == 'webadapters' %}
        <section class="intro-section mb-12">
            <h3 id="overview">Overview</h3>
            <p><strong>Web Adapters</strong> are the pragmatic bridge between the ideal world of Web Everything standards and the rich ecosystem of existing tools. They fall into two main categories: Syntactic improvements for better Developer Experience (DX), and Library bridges that make third-party tools compliant with our protocols.</p>
        </section>

        <section class="adapters-section">
            {% for category in adapters %}
            <div class="adapter-category mb-12">
                <h3 id="category-title" class="text-xl font-bold mb-4 border-b border-gray-200 pb-2">{{ category.title }}</h3>
                <p class="mb-6 text-gray-600">{{ category.description }}</p>
                
                <div class="standards-grid">
                    {% for item in category.items %}
                    <div class="standard-card">
                        <div class="flex justify-between items-start mb-3">
                            <h4 id="item-name" class="text-lg font-bold m-0 text-gray-900">{{ item.name }}</h4>
                        </div>
                        <p class="text-gray-600 text-sm leading-relaxed mb-0">{{ item.desc | safe }}</p>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </section>
    {% endif %}

    {% if project.id == 'webintents' %}
        <section class="intro-section mb-12">
            <h3 id="mission">Mission</h3>
            <p>
                <strong>Web Intents</strong> allow applications to declare widespread UX behavior preferences (like density, motion, or interaction models) that all componentsregardless of originadhere to.
                Instead of micro-managing prop drilling for every component (e.g., <code>&lt;Button dense /&gt;</code>, <code>&lt;List dense /&gt;</code>), you declare the <strong>Intent</strong> at the root or section level, and the components adapt automatically.
            </p>
        </section>

        <section id="proposed-intents" class="section-card">
            <h3 id="proposed-standard-intents">Proposed Intents</h3>
            
            <div class="standards-grid">
                {% for intent in intents %}
                <a href="/intents/{{ intent.id }}/" class="standard-card">
                    <div class="flex justify-between items-start mb-3">
                        <h4 id="intent-{{ intent.id }}" class="text-lg font-bold m-0 text-gray-900">{{ intent.name }}</h4>
                    </div>
                    <p class="text-gray-600 text-sm leading-relaxed mb-4">{{ intent.summary }}</p>
                    <div style="margin-bottom: 1rem;">
                        {{ projectStatus(intent.status) }}
                    </div>
                </a>
                {% endfor %}
            </div>
        </section>

         <section id="implementation" class="section-card">
            <h3 id="implementation-details">How It Works</h3>
            <p>
                Intents can be applied in two ways, depending on your architecture:
            </p>
            <ul class="mb-4 list-disc pl-5">
                <li><strong>Runtime Contexts</strong>: For dynamic preferences (e.g., user toggles settings). implementations are loaded and swapped on the fly.</li>
                <li><strong>Build-Time Selection</strong>: For fixed application profiles. This allows for dead-code elimination (e.g. if "Compact" is selected, "Comfortable" code is never bundled).</li>
            </ul>
            <p class="mb-4">
                Both strategies rely on the same <a href="/projects/webinjectors/">Web Injectors</a> syntax. 
                In a dynamic environment, the resolution happens at runtime. If a compiler is present, it can resolve the dependency at build-time for optimization (Dead Code Elimination).
            </p>
           {% highlight "json" %}
// myapp.intents.json
{
  "intents": {
    "motion": "immediate",
    "density": "compact",
    "mode": "night"
  }
}
            {% endhighlight %}
            {% highlight "typescript" %}
// Application Injector Setup
injector App {
    provide { intents } to '@web-intents' from './intents';
    // Or
    provide { intents } to '@web-intents' from './intents.json' with { type: 'json' };
    // Or for run-time resolution, actual .json content can be swapped dynamically
    provide { intents } to '@web-intents' from 'https://myapp.com/intents.json' with { type: 'json' };
}
            {% endhighlight %}
            {% highlight "typescript" %}
// Component Injector Setup
injector Component extends import.injector {
    consume { mode, density } of '@web-intents';
    const { withMode } = await import(`./traits/mode.${mode}`);
    const { density } = await import(`./constants/density.${density}`);
    // Provide to default domain
    provide { withMode, density };
}
            {% endhighlight %}            
            {% highlight "typescript" %}
// Component Source
consume { density, withMode };

class MyComponent extends HTMLElement {
    connectedCallback() {
        this.style.padding = density.spacing.md;
    }
}

withMode(Component); // applies mode trait
            {% endhighlight %}
        </section>
    {% endif %}

    {% if project.id == 'webtraits' %}
        <section class="intro-section mb-12">
            <h3 id="mission">Mission</h3>
            <p>{{ traits.mission }}</p>
        </section>

        <section class="traits-pillars mb-12">
            <h3 id="the-trinity" class="text-xl font-bold mb-6">The Trinity</h3>
            <div class="traits-trinity-grid">
                {% for pillar in traits.pillars %}
                <div class="standard-card">
                    <h4 class="text-lg font-bold m-0 text-gray-900 no-toc">{{ pillar.title }}</h4>
                    <span class="text-xs uppercase tracking-wider text-blue-600 font-bold mb-2 block">{{ pillar.subtitle | safe }}</span>
                    <p class="text-gray-600 text-sm leading-relaxed mb-3">{{ pillar.desc | safe }}</p>
                    <p class="text-xs text-gray-500 italic border-t pt-2 mt-auto">{{ pillar.details | safe }}</p>
                </div>
                {% endfor %}
            </div>
        </section>

        <section class="traits-example traits-vision-box">
            <h3 id="the-vision" class="text-lg font-bold mb-4">The Vision</h3>
            <div class="traits-vision-grid">
                <div>
                    <h5 class="text-sm font-bold text-gray-500 uppercase mb-2">Developer writes (DX)</h5>
                    <pre class="code-block-dark"><code>{{ traits.example.usage }}</code></pre>
                    <p class="text-sm text-gray-600">Simple, declarative. No manual imports of specific features.</p>
                </div>
                <div>
                    <h5 class="text-sm font-bold text-gray-500 uppercase mb-2">User gets (UX)</h5>
                    <pre class="code-block-dark"><code>{{ traits.example.result }}</code></pre>
            </div>
        </section>

        <section style="margin-top: var(--spacing-lg);">
            <h3 id="reference-implementation" class="text-xl font-bold mb-4">{{ traits.tech_details.title }}</h3>
            
            <div class="bg-amber-50 border-l-4 border-amber-500 p-4 mb-8">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-amber-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-amber-700">
                            {{ traits.tech_details.warning }}
                        </p>
                    </div>
                </div>
            </div>

            <div class="traits-steps-stack">
                {% for step in traits.tech_details.steps %}
                <div class="traits-vision-box" style="margin-top: 0;">
                    <h4 id="{{ step.title | slug }}" class="text-lg font-bold mb-2">{{ step.title }}</h4>
                    <p class="text-gray-600 text-sm mb-4">{{ step.desc }}</p>
                    <pre class="code-block-dark mb-0"><code>{{ step.code }}</code></pre>
                </div>
                {% endfor %}
            </div>
        </section>
    {% endif %}

    {% if project.id == 'webdocs' %}
        <section class="intro-section mb-12">
            <h3 id="overview">Overview</h3>
            <p>{{ docs.intro | safe }}</p>
        </section>

        <section class="docs-section">
            <h3 id="specifications" class="text-xl font-bold mb-6">Specifications</h3>
            <div class="standards-stack">
                {% for spec in docs.specs %}
                <div class="standard-card flex flex-col">
                    <div class="mb-3">
                        <h4 id="spec-title" class="text-lg font-bold m-0 text-gray-900">{{ spec.title }}</h4>
                        {% if spec.subtitle %}
                            <span class="text-sm text-gray-500 font-normal">{{ spec.subtitle }}</span>
                        {% endif %}
                    </div>
                    <p class="text-gray-600 text-sm leading-relaxed mb-4 flex-grow">{{ spec.description }}</p>
                    
                    {% if spec.note %}
                    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 mb-4 text-xs text-blue-800">
                        <strong>Note:</strong> {{ spec.note }}
                    </div>
                    {% endif %}

                    {% if spec.code %}
                    <div class="mt-auto">
                        <pre class="bg-gray-800 text-gray-100 p-3 rounded text-xs overflow-x-auto font-mono mb-0"><code>{{ spec.code }}</code></pre>
                    </div>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </section>
    {% endif %}
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.21.0/tocbot.min.js"></script>
<script>
    // Initialize Tocbot
    tocbot.init({
        tocSelector: '.toc',
        contentSelector: '.project-body',
        headingSelector: 'h3, h4:not(.no-toc)',
        hasInnerContainers: true,
        scrollSmooth: true,
        scrollSmoothDuration: 400,
        scrollSmoothOffset: -120, // Increased to account for header + spacing
        headingsOffset: 120,      // improved intersection detection
    });
</script>
