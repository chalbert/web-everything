---
pagination:
    data: projects
    size: 1
    alias: project
permalink: "projects/{{ project.id }}/"
layout: base.njk
mainClass: "project-page-container"
eleventyComputed:
    title: "Web Everything - {{ project.name }}"
---

{% from "project-status.njk" import projectStatus %}

<div class="project-detail-header">
    <div class="project-detail-icon">
        {% if project.isSvg %}
            <img src="{{ project.icon }}" alt="{{ project.name }} icon" width="64" height="64">
        {% else %}
            {{ project.icon }}
        {% endif %}
    </div>
    <h1 class="project-detail-title">{{ project.name }}</h1>
    <p class="project-detail-desc">{{ project.description | safe }}</p>
    
    <div class="project-detail-status">
        <!-- Status Link -->
        <a href="/project-lifecycle/" class="status-lifecycle-link" aria-label="Learn about the project lifestyle stages">
            {{ projectStatus(project.status) }}
        </a>
    </div>
</div>

<div class="project-layout">
    <aside class="project-sidebar">
        <div class="toc-container">
            <h3>Table of Contents</h3>
            <nav class="toc">
                <!-- Tocbot will inject content here -->
            </nav>
        </div>
        <div class="action-area" style="margin-top: 2rem;">
            <a href="/" class="btn-back">
                &larr; Back to Home
            </a>
        </div>
    </aside>

    <div class="project-body">
    {% if project.id == 'webinjectors' %}
        <section id="concept" class="section-card">
            <h3>The Concept</h3>
            <p>
                <strong>Web Injectors</strong> introduces a first-class language construct related to managing dependency injection and scope flow directly in TypeScript/JavaScript.
                It moves beyond "Import Maps" by allowing dynamic, hierarchical, and domain-based resolution of resources.
            </p>
        </section>

        <section id="syntax" class="section-card">
            <h3>Core Syntax</h3>
            <ul>
                <li><code>injector</code>: Declares a new dependency container. Similar to a <code>namespace</code> or <code>module</code> but specifically for dependency resolution.</li>
                <li><code>provide</code>: Exposes values from an injector to a specific domain or globally.</li>
                <li><code>consume</code>: Injects values from a specific domain into the current scope.</li>
                <li><code>domain</code>: A string identifier (e.g., <code>'@app/core'</code>). <strong>This is the contract.</strong> It acts as a universal namespace that prevents naming collisions (e.g., <code>@auth/session</code> vs <code>@analytics/session</code>) and decouples the interface from the implementation.</li>
            </ul>
        </section>

        <section id="deep-dive" class="section-card">
            <h3>Deep Dive: Syntax & Usage</h3>

            <h4>1. Basic Injector Definition</h4>
            <p>An <code>injector</code> is a block that encapsulates resources. You can export it just like a class or variable.</p>
            {% highlight "typescript" %}
// definitions.ts
export injector definitions {
    // Define resources inside the injector
    const Resource = 100;
    
    // Expose them to the outside world
    provide { Resource };
}
            {% endhighlight %}

            <h4>2. Consuming Dependencies</h4>
            <p>Consumers request resources from a specific "domain" string. This decouples the consumer from the concrete implementation file.</p>
            {% highlight "typescript" %}
// consumer.ts
// We don't import from 'definitions.ts'. 
// We consume from the abstract domain '@definitions'.
consume { Resource } of '@definitions';

const r: number = Resource; // 'Resource' is now available in this scope
            {% endhighlight %}

            <h4>3. Composition & Wiring</h4>
            <p>The "Main" or "Root" of the application wires the concrete implementation (<code>definitions</code>) to the abstract domain (<code>@definitions</code>).</p>
            {% highlight "typescript" %}
// main.ts
import { definitions } from "./definitions";

export injector main {
    // 1. Contextualize: Map the concrete 'definitions' injector 
    //    to the abstract identifier '@definitions'.
    provide * to '@definitions' from definitions;

    // 2. Include the consumer code into this execution context
    provide * from "./consumer";
}
            {% endhighlight %}
        </section>

        <section id="case-study" class="section-card">
            <h3>Case Study: The "Hollow" Calendar Widget</h3>
            <p>
                Modern UI libraries (like <code>react-calendar</code> or <code>mui-datepicker</code>) are often monolithic bundles containing date math, formatting logic, positioning engines, and styling.
                With <strong>Web Injectors</strong>, we can build a "hollow" widget that delegates all complexity to injected protocols.
            </p>

            <h4>Deconstructing the Calendar</h4>
            <p>A rich calendar widget actually encapsulates several distinct domains:</p>
            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                <div class="content-box" style="padding: 1rem;">
                    <strong>Date Logic</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Adding months, calculating start-of-week, validation.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/core</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Localization</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Formatting "MMMM YYYY", day names "Mon/Tue".</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/fmt</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Positioning</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Floating element anchor, collision detection.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/floating</code>
                </div>
                <div class="content-box" style="padding: 1rem;">
                    <strong>Icons</strong>
                    <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Chevron Left/Right, Calendar icon.</p>
                    <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/icons</code>
                </div>
            </div>

            <h4>The Widget Implementation</h4>
            <p>Notice how the component below contains <strong>zero</strong> implementation logic. It is purely an orchestrator.</p>

            {% highlight "typescript" %}
// components/calendar.ts
// -----------------------
// 1. Declare dependencies on abstract domains
consume { addMonths, startOfMonth, getDaysInMonth } of '@date/core';
consume { format }                                  of '@date/fmt';
consume { useFloating, offset, flip }               of '@ui/floating';
consume { ChevronLeft, ChevronRight }               of '@ui/icons';

export class HollowCalendar extends HTMLElement {
  connectedCallback() {
      this.render();
  }

  render() {
      // 2. Use the injected 'format' function
      // The widget doesn't know if this is using Intl, date-fns, or moment.
      const title = format(new Date(), 'MMMM yyyy');

      // 3. Use the injected 'Chevron' icons
      // The widget doesn't know if these are SVGs, FontAwesome, or Images.
      this.innerHTML = `
        <header>
           <button>${ChevronLeft}</button>
           <span>${title}</span>
           <button>${ChevronRight}</button>
        </header>
        <div class="grid">
           <!-- Days rendered here using injected math -->
        </div>
      `;
  }
}
            {% endhighlight %}

            <h4>The Wiring (Application Root)</h4>
            <p>This is where we decide <em>how</em> the calendar behaves in this specific application.</p>

            {% highlight "typescript" %}
// app.ts
import { DateFnsAdapter } from "./adapters/date-fns";
import { FloatingUIDOM } from "./adapters/floating-ui";
import { FontAwesomeIcons } from "./theme/fa-icons";

// Create the unified environment
export injector AppEnvironment {
    // Bind specific libraries to the abstract domains
    provide * to '@date/core'     from DateFnsAdapter;
    provide * to '@date/fmt'      from DateFnsAdapter;
    provide * to '@ui/floating'   from FloatingUIDOM;
    provide * to '@ui/icons'      from FontAwesomeIcons;
}

// Now render the app
// <hollow-calendar> will automatically receive the provided implementations.
            {% endhighlight %}
        </section>

        <section id="why" class="section-card">
            <h3>Why This Matters?</h3>
            <p>
                This pattern allows for true <strong>Inversion of Control</strong> at the language level. 
                Your <code>consumer.ts</code> never needs to know where <code>Resource</code> comes from, or even if it was mocked for testing. 
                The <code>main</code> injector acts as the composition root, binding <code>RealService</code> to <code>@service</code> in production, or <code>MockService</code> to <code>@service</code> in tests.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webbehaviors' %}
        <section id="concept" class="section-card">
            <h3>The Concept</h3>
            <p>
                <strong>Web Behaviors</strong> enable developers to attach rich functionality to any DOM element using custom attributes.
                This brings the "Decorator" pattern to HTML, allowing for powerful composition without the need for component wrappers. Web Behaviors are registered to the <code>CustomAttributeRegistry</code>.
            </p>
        </section>

        <section id="case-study" class="section-card">
            <h3>Case Study: Router Links</h3>
            <p>
                In many SPAs, you need a special component (like <code>&lt;Link&gt;</code> or <code>&lt;router-link&gt;</code>) to handle navigation without reloading the page.
                This forces you to replace standard <code>&lt;a&gt;</code> tags with framework-specific components that might struggle to emulate all native behavior (accessibility, drag-to-tab, context menus).
            </p>
            <p><strong>With Web Behaviors:</strong> You simply enhance the standard anchor tag.</p>

            {% highlight "html" %}
<!-- Standard HTML, upgraded behavior -->
<a href="/profile" history-link>My Profile</a>

<!-- Composition: A button that acts as a link -->
<button history-link="/dashboard">Go to Dashboard</button>
            {% endhighlight %}

            <div class="comparison-block" style="background: rgba(99, 102, 241, 0.05); padding: 1.25rem; border-radius: 8px; border-left: 4px solid var(--color-primary); margin: 2rem 0;">
                <h4 style="margin-top: 0; color: var(--color-primary); font-size: 1rem;">Note: vs Customized Built-in Elements</h4>
                <p style="margin-bottom: 0.5rem; font-size: 0.95rem;">
                    The Web Components standard allows extending native elements using the <code>is</code> attribute (e.g., <code>&lt;button is="my-button"&gt;</code>).
                </p>
                <p style="margin-bottom: 0; font-size: 0.95rem;">
                    <strong>The limitation?</strong> An element can only have <em>one</em> <code>is</code> value (single inheritance). 
                    <strong>Web Behaviors</strong> allow for <strong style="color: var(--color-primary);">composition</strong>, meaning you can attach as many independent functional attributes as needed to a single element.
                </p>
            </div>
        </section>

        <section id="implementation" class="section-card">
            <h3>The Implementation</h3>
            <p>
                Following the reference implementation in <strong>Web Plugs</strong>, a Behavior is a class that receives the <code>ownerElement</code> and uses standard lifecycle hooks.
            </p>

            {% highlight "typescript" %}
import { CustomAttribute } from '@web-plugs/web-behaviors';

class HistoryLink extends CustomAttribute {
    // Observe changes to the 'href' attribute
    static get observedAttributes() { return ['href']; }

    connectedCallback() {
        // Enhance the element with a click listener
        this.ownerElement.addEventListener('click', this.navigate);
    }
    
    disconnectedCallback() {
        this.ownerElement.removeEventListener('click', this.navigate);
    }

    navigate = (e) => {
        // Prevent full page reload
        e.preventDefault();
        
        // Determine URL from attribute value OR element's href
        const url = this.value || this.ownerElement.getAttribute('href');
        
        // Push to History API
        window.history.pushState(null, '', url);
    }
}

// Register the behavior
customAttributes.define('history-link', HistoryLink);
            {% endhighlight %}
        </section>

        <section id="specs" class="section-card">
            <h3>Standard Specification (Draft)</h3>
            <p>To formalize Web Behaviors as a platform standard, the following interfaces and augmentations would be introduced to the HTML specification.</p>

            <h4>1. new class CustomAttribute</h4>
            <p>
                The base class for all behaviors. It mirrors the lifecycle of Custom Elements but is scoped to an attribute.
                <strong>Requirement:</strong> Attribute names must contain a hyphen (e.g., <code>my-attr</code>) to avoid collision with standard HTML attributes.
            </p>
            {% highlight "typescript" %}
interface CustomAttribute {
    // Properties
    readonly ownerElement: Element;
    readonly name: string;
    readonly value: string;

    // Lifecycle Callbacks
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    attributeChangedCallback?(
        name: string, 
        oldValue: string | null, 
        newValue: string | null
    ): void;

    // Static
    static readonly observedAttributes?: string[];
}
            {% endhighlight %}

            <h4>2. new interface CustomAttributeRegistry</h4>
            <p>The global registry handling behavior definitions, similar to <code>customElements</code>.</p>
            {% highlight "typescript" %}
interface CustomAttributeRegistry {
    define(name: string, constructor: CustomAttributeConstructor, options?: any): void;
    get(name: string): CustomAttributeConstructor | undefined;
    upgrade(root: Node): void;
    whenDefined(name: string): Promise<CustomAttributeConstructor>;
}
            {% endhighlight %}

            <h4>3. Extensions to Window</h4>
            <p>Exposing the registry on the global object.</p>
            {% highlight "typescript" %}
interface Window {
    readonly customAttributes: CustomAttributeRegistry;
}
            {% endhighlight %}

            <h4>4. Ecosystem Dependencies</h4>
            <div class="content-box">
                <ul style="margin: 0; padding-left: 1.25rem;">
                    <li><strong>Web Registries:</strong> The <code>CustomAttributeRegistry</code> must implement the unified Registry interface defined by the Web Registries spec.</li>
                    <li><strong>DOM Mutation API:</strong> The polyfill implementation (Web Plug) relies on <code>MutationObserver</code> to detect attribute additions/removals. A native browser implementation would optimize this event loop internally.</li>
                </ul>
            </div>
        </section>

        <section id="examples" class="section-card">
            <h3>Userland Examples</h3>
            <p>
                Behaviors are exceptionally versatile. Here is a showcase of potential use cases ranging from UI interactions to data management.
            </p>

            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-top: 1.5rem; margin-bottom: 2rem;">
                
                <!-- UI Interactions -->
                <div class="content-box">
                    <h4 style="color: var(--color-primary); margin: 0 0 0.5rem 0;">UI Interactions</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>click-outside</code>:
                            <br><span>Detects clicks outside the element (useful for modals/dropdowns).</span>
                        </li>
                        <li>
                            <code>ripple-effect</code>:
                            <br><span>Material Design-style ink ripple on click.</span>
                        </li>
                        <li>
                            <code>draggable-item</code>:
                            <br><span>Makes an element draggable within a container (Kanban style).</span>
                        </li>
                        <li>
                            <code>scroll-lock</code>:
                            <br><span>Prevents scroll on body when this element is active/open.</span>
                        </li>
                    </ul>
                </div>

                <!-- Data & Forms -->
                <div class="content-box">
                    <h4 style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Forms & Data</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>bind-value="prop"</code>:
                            <br><span>Two-way data binding between an input and a state property.</span>
                        </li>
                        <li>
                            <code>validate-email</code>:
                            <br><span>Adds custom validity checks to an input field.</span>
                        </li>
                        <li>
                            <code>auto-grow</code>:
                            <br><span>Automatically resizes a <code>&lt;textarea&gt;</code> based on content height.</span>
                        </li>
                        <li>
                            <code>copy-to-clipboard</code>:
                            <br><span>Copies the element's text content on click.</span>
                        </li>
                    </ul>
                </div>

                <!-- Visibility & Layout -->
                <div class="content-box">
                    <h4 style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Visibility & Lifecycle</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>lazy-load</code>:
                            <br><span>Only loads content (image/iframe) when element enters viewport.</span>
                        </li>
                        <li>
                            <code>animate-on-scroll</code>:
                            <br><span>Triggers a CSS animation class when scrolled into view.</span>
                        </li>
                        <li>
                            <code>hide-element="condition"</code>:
                            <br><span>Toggles <code>display: none</code> based on a reactive state.</span>
                        </li>
                        <li>
                            <code>pop-element</code>:
                            <br><span>Manages <code>popover</code> API behavior with enhanced positioning.</span>
                        </li>
                    </ul>
                </div>

                <!-- Advanced Logic -->
                <div class="content-box">
                    <h4 style="color: var(--color-primary); margin: 0 0 0.5rem 0;">Advanced Patterns</h4>
                    <ul style="font-size: 0.95rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li>
                            <code>provide-store="key"</code>:
                            <br><span>Exposes a store instance to the subtree context.</span>
                        </li>
                        <li>
                            <code>track-analytics="event"</code>:
                            <br><span>Sends a telemetry event when the user interacts with the element.</span>
                        </li>
                        <li>
                            <code>composite-widget</code>:
                            <br><span>Orchestrates multiple child behaviors into a single logical unit.</span>
                        </li>
                    </ul>
                </div>

            </div>
        </section>

        <section id="why" class="section-card">
            <h3>Why This Matters?</h3>
            <ul>
                <li><strong>Styling Preserved:</strong> No extra <code>&lt;div&gt;</code> wrappers breaking Flexbox or Grid layouts.</li>
                <li><strong>Accessibility:</strong> You enhance native elements definition (progressive enhancement) rather than replacing them with semantically ambiguous custom tags.</li>
                <li><strong>Composition:</strong> An element can have multiple behaviors simultaneously: <br><code>&lt;input validate-email track-change auto-save&gt;</code>.</li>
            </ul>
        </section>
    {% endif %}

    {% if project.id == 'webregistries' %}
        <section id="protocol" class="section-card">
            <h3>The Protocol</h3>
            <p>
                <strong>Web Registries</strong> define a standard interface for creating scoped, hierarchical registries on the web platform. 
                Where standard <code>Map</code> or <code>CustomElementRegistry</code> are flat and global, Web Registries are designed for **inheritance** and **scoping**.
            </p>
        </section>

        <section id="features" class="section-card">
            <h3>Key Features</h3>
            <ul>
                <li><strong>Standard Interface:</strong> All registries implement a common <code>get</code>, <code>has</code>, <code>set</code> (via <code>define</code>) API.</li>
                <li><strong>Inheritance:</strong> A registry can extend one or more parent registries. Lookups traverse the chain automatically.</li>
                <li><strong>Scoping:</strong> Enables different parts of an application to have different definitions for the same key (e.g., scoping icons or formatters to a specific routed view).</li>
            </ul>
        </section>

        <section id="standards" class="section-card">
            <h3>Proposed Standards</h3>
            <p>The <strong>Web Everything</strong> platform proposes standardizing registries for nearly every aspect of the DOM, allowing for unprecedented extensibility:</p>
            
            <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
                <div>
                    <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">DOM Primitives</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomElementRegistry</code> (Standard/Polyfilled)</li>
                        <li><code>CustomAttributeRegistry</code></li>
                        <li><code>CustomCommentRegistry</code></li>
                        <li><code>CustomTextNodeRegistry</code></li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">Parsing Engine</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomAttributeParserRegistry</code></li>
                        <li><code>CustomTextNodeParserRegistry</code></li>
                        <li><code>CustomPathExpressionParserRegistry</code></li>
                        <li><code>CustomCommentParserRegistry</code></li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: var(--color-primary); margin-bottom: 0.5rem;">Logic & Data</h4>
                    <ul style="font-size: 0.9rem; padding-left: 1.25rem; color: var(--color-text-muted);">
                        <li><code>CustomContextRegistry</code></li>
                        <li><code>CustomStoreRegistry</code></li>
                        <li><code>CustomEventRegistry</code></li>
                        <li><code>HTMLRegistry</code> (Injectors)</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="examples" class="section-card">
            <h3>Userland Examples</h3>
            
            <h4>Example 1: Icon System</h4>
            <p>You can define your own registries for application-specific needs. Here is how you might build an Icon Registry that supports overriding icons in different contexts.</p>

            {% highlight "javascript" %}
import { CustomRegistry } from '@web-plugs/web-registries';

// 1. Define the Registry Class
class IconRegistry extends CustomRegistry {
  localName = 'icons'; // Used for debugging/identification
}

// 2. Create the registries
const globalIcons = new IconRegistry();
globalIcons.define('menu', '<svg viewBox="0 0 24 24">...</svg>');
globalIcons.define('close', '<svg viewBox="0 0 24 24">...</svg>');

// 3. Create a Scoped Registry (e.g., for a specific Admin module)
// It inherits everything from globalIcons, but can shadow them
const adminIcons = new IconRegistry({ 
  extends: [globalIcons] 
});

// Override 'menu' only for this scope
adminIcons.define('menu', '<svg viewBox="0 0 24 24">...<!-- Admin Menu --></svg>');
            {% endhighlight %}

            <p><strong>Connecting to Components:</strong> A theoretical <code>&lt;ui-icon&gt;</code> component illustrating how to consume the registry.</p>

            {% highlight "html" %}
<script type="module">
  // Hypothetical component that consumes our IconRegistry
  class UIIcon extends HTMLElement {
    connectedCallback() {
      // In a real app, 'adminIcons' might be provided via Context or Dependency Injection
      // For this POC demonstration, we import it directly.
      const registry = this.hasAttribute('admin') ? adminIcons : globalIcons;
      
      const iconName = this.getAttribute('name');
      if (registry.has(iconName)) {
         this.innerHTML = registry.get(iconName);
      }
    }
  }
  customElements.define('ui-icon', UIIcon);
</script>

<!-- Usage -->
<ui-icon name="menu"></ui-icon>         <!-- Renders standard menu -->
<ui-icon name="menu" admin></ui-icon>   <!-- Renders admin menu (via scoped registry) -->
            {% endhighlight %}
        </section>
    {% endif %}

    {% if project.id == 'webcontexts' %}
        <section id="protocol" class="section-card">
            <h3>The Protocol</h3>
            <p>
                <strong>Web Contexts</strong> brings a robust, Dependency Injection-based context system to the HTML platform. 
                It allows data and services to be provided hierarchically down the DOM tree, available to any component that requests them.
            </p>
        </section>

        <section id="use-cases" class="section-card">
            <h3>Key Use Cases</h3>
            <ul>
                <li><strong>State Management:</strong> Provide reactive state stores (Redux, Signals) to a subtree of components.</li>
                <li><strong>Theming:</strong> Cascade design tokens or theme definitions without passing props through every layer.</li>
                <li><strong>Service Injection:</strong> Make API clients, loggers, or authentication services available to declarative widgets.</li>
            </ul>
        </section>

        <section id="comparison" class="section-card">
            <div class="comparison-block" style="background: rgba(99, 102, 241, 0.1); padding: 1.5rem; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.2); margin: 2rem 0;">
                <h4 style="margin-top: 0; color: var(--color-primary);">Current Standardization vs. Web Contexts</h4>
                
                <p><strong>The Current Standard (Community Protocol):</strong> Relies on <em>Events</em> (<code>context-request</code>). A consumer dispatches an event, which bubbles up until a generic <code>context-provider</code> element catches it.</p>
                
                <p><strong>The Limitation:</strong> To provide context to a list of elements (e.g., in a loop), you must wrap them in a parent provider element.</p>
                {% highlight "html" %}
<!-- Wrapper required for context -->
<context-provider>
   <my-item>...</my-item>
   <my-item>...</my-item>
</context-provider>
                {% endhighlight %}
                <p><em>This wrapper can break CSS layouts (Grid/Flex) and complicate DOM structure.</em></p>

                <hr style="border: 0; border-top: 1px solid rgba(99, 102, 241, 0.2); margin: 1rem 0;">

                {% highlight "html" %}
<!-- Virtual Scope: No wrapper element rendered -->
<!-- scope: theme-context -->
   <my-item>...</my-item>
   <my-item>...</my-item>
                {% endhighlight %}
                <p><strong>The Result:</strong> Multiple elements receive the single context <em>without</em> a physical DOM parent, maintaining your clean layout.</p>
            </div>
        </section>

        <section id="try-it" class="section-card">
            <h3>Try It Out</h3>
            <p>
                This protocol is fully implemented and available for use today. 
                Check out the reference implementation in the <strong><a href="/projects/webplugs/">Web Plugs</a></strong> collection.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webtokens' %}
        <section id="concept" class="section-card">
            <h3>The Concept</h3>
            <p>
                <strong>Web Tokens</strong> represents a collection of advanced parsing technologies that allow developers to imbue standard DOM text nodes and attributes with custom behavior. 
                Where standard HTML is static, Tokens make the text itself alive.
            </p>
        </section>

        <section id="components" class="section-card">
            <h3>Components</h3>
            <ul>
                <li><strong>Custom Text Nodes:</strong> Define behaviors for specific text patterns within the DOM.</li>
                <li><strong>Custom Text Node Parsers:</strong> The engine that scans and upgrades text nodes into functional run-time objects.</li>
                <li><strong>Web Path Parsers:</strong> Registries for resolving complex data paths (like XPath or JSONPath) directly in your templates.</li>
                <li><strong>Web Attribute Parsers:</strong> Enable custom syntax within attributes (e.g., <code>{{ double_curly }}</code>) to trigger dynamic updates.</li>
            </ul>
        </section>
    {% endif %}

    {% if project.id == 'webdirectives' %}
        <section id="concept" class="section-card">
            <h3>The Concept</h3>
            <p>
                <strong>Web Directives</strong> provides a unified system for control flow and logic in HTML. 
                It combines standard structural directives (loops, conditionals) with invisible "Comment Directives" and powerful "Template Directives".
            </p>
        </section>

        <section id="pillars" class="section-card">
            <h3>Three Pillars</h3>
            <ul>
                <li><strong>Structural Directives:</strong> Standard attributes (like <code>*if</code> or <code>*for</code>) for manipulating DOM layout.</li>
                <li><strong>Comment Directives:</strong> Use HTML comments to attach logic without extra wrapper elements. Perfect for "ghost" behaviors (formerly Web Figments).</li>
                <li><strong>Template Directives:</strong> Advanced extensions for the <code>&lt;template&gt;</code> element to control instantiation and projection.</li>
            </ul>
        </section>

        <section id="why" class="section-card">
            <h3>Why Comment Directives?</h3>
            <p>
                Sometimes you need logic (like a conditional render) but you don't want a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> wrapper breaking your CSS grid or Flexbox layout. 
                Comment directives allow you to anchor this logic to invisible markers in the DOM.
            </p>
        </section>
    {% endif %}

    {% if project.id == 'webplugs' %}
        <section id="overview" class="section-card">
            <h3>Overview</h3>
            <p>
                <strong>Web Plugs</strong> is the foundational layer of the Web Everything platform. 
                It provides the necessary polyfills and patches to the native browser environment to enable the advanced features required by downstream projects.
            </p>
            <p>
                Each "Plug" is a modular slice of functionality. They are designed to depend on each other hierarchically, allowing you to only load what you need.
            </p>

            <div class="mt-6 p-4 bg-gray-50 rounded-lg border border-gray-100">
                <h4 class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-3">Plug Types</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                    <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 mr-2 border border-blue-200">New Primitive</span>
                        <span class="text-gray-600 text-xs">Abstract base classes</span>
                    </div>
                    <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 mr-2 border border-emerald-200">New Global</span>
                        <span class="text-gray-600 text-xs">New window objects</span>
                    </div>
                     <div class="flex items-center">
                        <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 mr-2 border border-amber-200">Patch</span>
                        <span class="text-gray-600 text-xs">Modifies native API</span>
                    </div>
                </div>
            </div>
        </section>

        <section id="registry-plugs" class="section-card">
            <h3>Web Registries Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webregistries/">Web Registries</a></p>

            <div>
                <h4>CustomRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>The abstract base class for all scoped registries. It standardizes the API for storing and retrieving definitions, supporting inheritance from parent registries.</p>
                
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomRegistry<Definition, Key> {
    abstract readonly localName: string;
    
    // Core Registry API
    define(name: Key, definition: Definition): void;
    get(name: Key): Definition | undefined;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>HTMLRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>
                    A specialized abstract registry for storing constructors that are bound to DOM nodes. 
                    It handles the complexity of "Upgrading" and "Downgrading" nodes when definitions are added or removed.
                </p>

                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface HTMLRegistry<Definition, DefType> extends CustomRegistry<
    Definition, 
    string
> {
    abstract readonly localName: string;

    // Node Lifecycle
    abstract upgrade(node: Node): void;
    abstract downgrade(node: Node): void;
    
    // Reverse Lookup
    getLocalNameOf(constructor: DefType): string | undefined;
}
                {% endhighlight %}
            </div>
            
            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomElementRegistry (Patch)</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch / Extension</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Replaces the native <code>window.customElements</code> with a version that extends <code>HTMLRegistry</code>. 
                    This keeps the native API compatible while unlocking the features of <strong>Web Registries</strong> (polyfilled scoping and inheritance).
                </p>

                <strong>Interface:</strong>
                 {% highlight "typescript" %}
class CustomElementRegistry extends HTMLRegistry<
    ElementDefinition, 
    ImplementedElement
> {
    // Standard CustomElementRegistry API
    define(
        name: string, 
        constructor: CustomElementConstructor, 
        options?: ElementDefinitionOptions
    ): void;
    get(name: string): CustomElementConstructor | undefined;
    whenDefined(name: string): Promise<CustomElementConstructor>;
    upgrade(root: Node): void;
}
                 {% endhighlight %}
            </div>
        </section>

        <section id="behaviors" class="section-card">
            <h3>Web Behaviors Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webbehaviors/">Web Behaviors</a></p>

            <div>
                <h4>CustomAttributesRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Exposes <code>window.customAttributes</code>. It monitors the DOM for attribute changes and facilitates the "Upgrade" of standard attributes into enhanced behaviors.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomAttributesRegistry extends HTMLRegistry<
    AttributeDefinition, 
    ImplementedAttribute
> {
    readonly localName = 'customAttributes';

    // Same behavior as CustomElementRegistry but for attributes
    define(
        name: string, 
        constructor: ImplementedAttribute, 
        options?: CustomAttributesOptions
    ): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomAttribute</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>
                    The base class for creating behaviors, similar to <code>HTMLElement</code>.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomAttribute {
    // Instance Properties
    readonly ownerElement: Element;
    readonly name: string;
    readonly value: string;
    
    // Lifecycle Callbacks
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    attributeChangedCallback?(
        name: string, 
        oldValue: string | null, 
        newValue: string | null
    ): void;
    
    // Static Configuration
    static readonly observedAttributes?: string[];
    static readonly formAssociated?: boolean;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomAttributeParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Allows defining parsing logic for attribute values.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomAttributeParserRegistry extends CustomRegistry<CustomAttributeParser> {
    readonly localName = 'CustomAttributeParsers';
    define(
        name: string, 
        parser: CustomAttributeParser
    ): void;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="contexts" class="section-card">
            <h3>Web Contexts Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webcontexts/">Web Contexts</a></p>

            <div>
                <h4>CustomContextRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>
                    Exposes <code>window.customContextTypes</code>. It allows registering context definitions that provide data flow deeply to children.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomContextRegistry extends HTMLRegistry<
    ContextDefinition, 
    ImplementedContext
> {
    readonly localName = 'customContextTypes';

    define(name: string, Context: ImplementedContext): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomContext</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>
                    Base class for defining a context provider.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomContext<ContextValue> {
    // Similar to CustomElement
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    adoptedCallback?(): void;

    // Context Specific
    contextConsumedCallback?(
        callback: (...args: unknown[]) => ContextValue
    ): void;
    static readonly observedContexts?: string[];
}
                {% endhighlight %}
            </div>
        </section>

        <section id="injectors" class="section-card">
            <h3>Web Injectors Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webinjectors/">Web Injectors</a></p>

            <div>
                <h4>InjectorRoot</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p>
                    The root container for dependency injection. It handles the map of all active injectors in the DOM tree.
                </p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
class InjectorRoot {
    // Retrieval Methods used by resolution algorithm
    static getInjectorRootOf(node: Node): InjectorRoot | undefined;
    static getProviderOf(node: Node, providerName: string): Provider | undefined;
    static getProvidersOf(node: Node): Map<string, Provider>;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="tokens" class="section-card">
            <h3>Web Tokens Plugs</h3>
            <p class="mb-4"><strong>Required by:</strong> <a href="/projects/webtokens/">Web Tokens</a></p>

            <div>
                <h4>CustomTextNodeRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Allows defining parsers for text content (e.g., Mustache syntax <code>{{ '{}' }}</code>).</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomTextNodeRegistry extends HTMLRegistry<
    TextNodeDefinition, 
    ImplementedTextNode
> {
    readonly localName = 'customTextNodes';
    define(name: string, TextNode: ImplementedTextNode): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomTextNodeParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Manages parsers that can interpret text node content.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomTextNodeParserRegistry extends CustomRegistry<CustomTextNodeParser> {
    readonly localName = 'customTextNodeParsers';
    define(
        name: string, 
        parser: CustomTextNodeParser
    ): void;
}
                {% endhighlight %}
            </div>
            
            <hr class="my-6 border-gray-200">

             <div>
                <h4>CustomPathExpressionParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Registry for path expression parsers.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomPathExpressionParserRegistry extends CustomRegistry<
    CustomPathExpressionParser
> {
    readonly localName = 'customPathExpressionParsers';
    define(
        name: string, 
        parser: CustomPathExpressionParser
    ): void;
    
    // Returns a Consumable that provides the resolved parser
    query(): Consumable<CustomPathExpressionParser>;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

             <div>
                <h4>CustomPathExpressionParser</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Standardizes how strings are parsed into executable paths (e.g. keypaths in bindings).</p>
                 <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomPathExpressionParser {
    abstract parse(text: string): Graph;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="comments" class="section-card">
            <h3>Web Comments Plugs</h3>
            <p class="mb-4"><strong>Experimental</strong></p>

            <div>
                <h4>CustomCommentRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Enables attaching behavior to comment nodes, useful for structural directives (like `virtual-element`).</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomCommentRegistry extends HTMLRegistry<
    CommentDefinition, 
    ImplementedComment
> {
    readonly localName = 'customComments';
    define(name: string, comment: ImplementedComment): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomComment</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Base class for enhanced comments.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
class CustomComment extends Comment {
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    optionsChangedCallback?(oldValue: unknown, newValue: unknown): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomCommentParserRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>CustomRegistry</code></p>
                <p>Parses comment content to identify custom comments.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomCommentParserRegistry extends CustomRegistry<CustomCommentParser> {
    readonly localName = 'customCommentParsers';
    define(
        name: string, 
        parser: CustomCommentParser
    ): void;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="scripting" class="section-card">
            <h3>Web Scripting Plugs</h3>
            <p class="mb-4"><strong>Experimental</strong></p>

             <div>
                <h4>CustomScriptTypesRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Allows defining custom behavior for <code>&lt;script type="..."&gt;</code> tags.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomScriptTypesRegistry extends HTMLRegistry<
    ScriptTypeDefinition, 
    ImplementedCustomScriptType
> {
    readonly localName = 'customScriptTypes';
    define(
        name: string, 
        scriptType: ImplementedCustomScriptType
    ): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomScriptType</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Base class extending <code>HTMLScriptElement</code>.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomScriptType extends HTMLScriptElement {
    connectedCallback?(): void;
    disconnectedCallback?(): void;
    adoptedCallback?(): void;
}
                {% endhighlight %}
            </div>
        </section>

        <section id="state" class="section-card">
            <h3>Web State Plugs</h3>
            <p class="mb-4"><strong>Experimental</strong></p>

            <div>
                <h4>CustomStoreRegistry</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800 border border-emerald-200">New Global</span></p>
                <p><strong>Dependency:</strong> <code>HTMLRegistry</code></p>
                <p>Registry for global state stores.</p>
                <strong>Interface:</strong>
                {% highlight "typescript" %}
interface CustomStoreRegistry extends HTMLRegistry<StoreDefinition, ImplementedStore> {
    readonly localName = 'customStores';
    define(
        name: string, 
        Store: ImplementedStore, 
        options?: CustomStoreRegistryOptions
    ): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>CustomStore</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200">New Primitive</span></p>
                <p>Abstract base for state containers.</p>
                 <strong>Interface:</strong>
                {% highlight "typescript" %}
abstract class CustomStore<State, Key> {
    abstract state: State;
    abstract subscribe(listener: StoreListener, query: any): StoreUnsubscribe;
    abstract getItem(key: Key): State[Key];
    abstract setItem(key: Key, value: State[Key]): void;
}
                {% endhighlight %}
            </div>

            <hr class="my-6 border-gray-200">

            <div>
                <h4>History (Patch)</h4>
                <p><strong>Type:</strong> <span class="px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800 border border-amber-200">Patch</span></p>
                <p>Patches the native History API to dispatch events on `pushState` and `replaceState`.</p>
                 <strong>Interface:</strong>
                {% highlight "typescript" %}
class History {
    pushState(state: any, unused: string, url?: string | URL | null): void; // Dispatches 'pushstate'
    replaceState(state: any, unused: string, url?: string | URL | null): void; // Dispatches 'replacestate'
}
                {% endhighlight %}
            </div>
        </section>
    {% endif %}
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.21.0/tocbot.min.js"></script>
<script>
    // Initialize Tocbot
    tocbot.init({
        tocSelector: '.toc',
        contentSelector: '.project-body',
        headingSelector: 'h3, h4',
        hasInnerContainers: true,
        scrollSmooth: true,
        scrollSmoothDuration: 400,
        scrollSmoothOffset: -100,
        headingsOffset: 100,
    });
</script>
