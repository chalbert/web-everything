[
  {
    "id": "clients",
    "name": "Custom Clients",
    "status": "draft",
    "summary": "Standard for abstracting data fetchers (HTTP, GQL, WS).",
    "description": "<h3>Design Philosophy</h3><p>A <strong>CustomResourceClient</strong> decouples the application from the transport layer. It aligns with the <strong>Apollo Link</strong> pattern but generalized for any request type.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomResourceClient {\n    // Returns a cold observable (Consumable)\n    execute(\n        operation: ResourceOperation\n    ): Consumable&lt;ResourceResult&gt;;\n}\n\ninterface ResourceOperation {\n    kind: 'query' | 'mutation' | 'subscription';\n    key: unknown[]; // Normalized ID\n    context: Record&lt;string, unknown&gt;;\n}</code></pre>"
  },
  {
    "id": "middleware",
    "name": "Custom Middleware",
    "status": "draft",
    "summary": "Standard for interceptors (Auth, Logging, Retry).",
    "description": "<h3>Design Philosophy</h3><p>Middleware allows cross-cutting concerns to be composed independently of the client. Aligns with <strong>Axios Interceptors</strong> but stackable via dependency injection.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">type MiddlewareNext = (\n    req: ResourceOperation\n) => Consumable&lt;ResourceResult&gt;;\n\ninterface CustomMiddleware {\n    process(\n        req: ResourceOperation,\n        next: MiddlewareNext\n    ): Consumable&lt;ResourceResult&gt;;\n}</code></pre>"
  },
  {
    "id": "cache",
    "name": "Custom Cache",
    "status": "draft",
    "summary": "Standard for defining validity and retention policies.",
    "description": "<h3>Design Philosophy</h3><p>Defining <em>how</em> long data is fresh should be separate from <em>where</em> it is stored. This protocol standardizes concepts from <strong>HTTP Cache-Control</strong> and <strong>TanStack Query</strong>.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomCachePolicy {\n    mode:\n        | 'cache-first'\n        | 'network-only'\n        | 'stale-while-revalidate';\n    maxAge: number; // ms\n    staleWhileRevalidate: number; // ms\n    key: (op: ResourceOperation) => string;\n}</code></pre>"
  },
  {
    "id": "tracer",
    "name": "Custom Tracer",
    "status": "draft",
    "summary": "Protocol for observability and request tracing, decoupled from the implementation.",
    "description": "<h3>Design Philosophy</h3><p><strong>Tracing</strong> (Lifecycle) is distinct from <strong>Tracking</strong> (User Behavior).</p><ul><li><strong>Tracing</strong>: Observes the <em>provenance</em> of the data (e.g., \"Request used Schema V2, took 50ms, transformed by Pipe X\").</li><li><strong>Tracking</strong>: Observes the <em>outcome</em> for business logic (e.g., \"User purchased item\").</li></ul><p>This protocol focuses on <strong>Context Propagation</strong> (via <strong>W3C Trace Context</strong>) and collecting safe execution metadata (Schema, Transformations) to establish provenance, independent of the storage backend.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomTracer {\n    // Wraps execution to measure duration\n    trace(\n        op: ResourceOperation,\n        execute: () => Consumable&lt;ResourceResult&gt;\n    ): Consumable&lt;ResourceResult&gt;;\n\n    // Injects tracing headers (W3C Trace Context)\n    injectContext(op: ResourceOperation): void;\n}</code></pre>"
  },
  {
    "id": "pagination",
    "name": "Custom Pagination",
    "status": "draft",
    "summary": "Standard for iterating over resource collections (Cursor, Offset, Page).",
    "description": "<h3>Design Philosophy</h3><p>Every API handles lists differently: <code>page/limit</code>, <code>offset/limit</code>, or <code>cursor/after</code>. This standard normalizes the iteration process into a simple <code>next()</code> protocol, allowing UI components (like InfiniteScroll) to consume any list without knowing the underlying strategy.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomPagination&lt;T&gt; {\n    // The current slice of data\n    readonly items: T[];\n\n    // Metadata\n    readonly hasNext: boolean;\n    readonly hasPrevious: boolean;\n    readonly total?: number;\n\n    // Navigation\n    next(): Promise&lt;CustomPagination&lt;T&gt;&gt;;\n    previous(): Promise&lt;CustomPagination&lt;T&gt;&gt;;\n}\n\ntype CustomPaginationDefinition =\n    | { strategy: 'offset'; limit?: number }\n    | { strategy: 'page'; limit?: number }\n    | { strategy: 'cursor'; limit?: number; key?: string };</code></pre>"
  },
  {
    "id": "resources",
    "name": "Custom Resources",
    "status": "draft",
    "summary": "Standard for defining resource entities and their data strategies (Registry).",
    "description": "<h3>Design Philosophy</h3><p>Just like <code>customElements</code> maps a tag name to a class, <strong>customResources</strong> maps a business entity (e.g. 'user', 'product') to its resource configuration. This allows the application to simply request <code>users</code> without knowing if it comes from GraphQL or REST.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomResourceRegistry\n    extends CustomRegistry&lt;ResourceDefinition&gt; {\n\n    readonly localName = 'customResources';\n\n    define(name: string, def: ResourceDefinition): void;\n\n    // Returns the config wrapper for a resource\n    get(name: string): ResourceHandle;\n}\n\ninterface ResourceDefinition {\n    // The Resolver\n    identify?: (params: unknown) => unknown[];\n    // e.g. OpenTelemetry\n    tracer?: CustomTracer;\n    // Strategy (Offset/Cursor)\n    pagination?: CustomPaginationDefinition;\n}</code></pre>"
  }
]
