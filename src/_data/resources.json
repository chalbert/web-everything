[
  {
    "id": "clients",
    "name": "Custom Clients",
    "status": "draft",
    "summary": "Standard for abstracting data fetchers (HTTP, GQL, WS).",
    "description": "<h3>Design Philosophy</h3><p>A <strong>CustomResourceClient</strong> decouples the application from the transport layer. It aligns with the <strong>Apollo Link</strong> pattern but generalized for any request type.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomResourceClient {    // Returns a cold observable (Consumable)    execute(operation: ResourceOperation): Consumable&lt;ResourceResult&gt;;}interface ResourceOperation {    kind: 'query' | 'mutation' | 'subscription';    key: unknown[]; // Normalized ID    context: Record&lt;string, unknown&gt;;}</code></pre>"
  },
  {
    "id": "middleware",
    "name": "Custom Middleware",
    "status": "draft",
    "summary": "Standard for interceptors (Auth, Logging, Retry).",
    "description": "<h3>Design Philosophy</h3><p>Middleware allows cross-cutting concerns to be composed independently of the client. Aligns with <strong>Axios Interceptors</strong> but stackable via dependency injection.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">type MiddlewareNext = (req: ResourceOperation) => Consumable&lt;ResourceResult&gt;;interface CustomMiddleware {    process(req: ResourceOperation, next: MiddlewareNext): Consumable&lt;ResourceResult&gt;;}</code></pre>"
  },
  {
    "id": "cache",
    "name": "Custom Cache",
    "status": "draft",
    "summary": "Standard for defining validity and retention policies.",
    "description": "<h3>Design Philosophy</h3><p>Defining <em>how</em> long data is fresh should be separate from <em>where</em> it is stored. This protocol standardizes concepts from <strong>HTTP Cache-Control</strong> and <strong>TanStack Query</strong>.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomCachePolicy {    mode: 'cache-first' | 'network-only' | 'stale-while-revalidate';    maxAge: number; // ms    staleWhileRevalidate: number; // ms    key: (op: ResourceOperation) => string;}</code></pre>"
  },
  {
    "id": "tracer",
    "name": "Custom Tracer",
    "status": "draft",
    "summary": "Protocol for observability and request tracing, decoupled from the implementation.",
    "description": "<h3>Design Philosophy</h3><p><strong>Tracing</strong> (Lifecycle) is distinct from <strong>Tracking</strong> (User Behavior).</p><ul><li><strong>Tracing</strong>: Observes the <em>provenance</em> of the data (e.g., \"Request used Schema V2, took 50ms, transformed by Pipe X\").</li><li><strong>Tracking</strong>: Observes the <em>outcome</em> for business logic (e.g., \"User purchased item\").</li></ul><p>This protocol focuses on <strong>Context Propagation</strong> (via <strong>W3C Trace Context</strong>) and collecting safe execution metadata (Schema, Transformations) to establish provenance, independent of the storage backend.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomTracer {    // Wraps the execution to measure duration and handle errors    trace(        op: ResourceOperation,         execute: () => Consumable&lt;ResourceResult&gt;    ): Consumable&lt;ResourceResult&gt;;    // Injects tracing headers (e.g. W3C Trace Context)    injectContext(op: ResourceOperation): void;}</code></pre>"
  },
  {
    "id": "pagination",
    "name": "Custom Pagination",
    "status": "draft",
    "summary": "Standard for iterating over resource collections (Cursor, Offset, Page).",
    "description": "<h3>Design Philosophy</h3><p>Every API handles lists differently: <code>page/limit</code>, <code>offset/limit</code>, or <code>cursor/after</code>. This standard normalizes the iteration process into a simple <code>next()</code> protocol, allowing UI components (like InfiniteScroll) to consume any list without knowing the underlying strategy.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomPagination&lt;T&gt; {    // The current slice of data    readonly items: T[];    // Metadata    readonly hasNext: boolean;    readonly hasPrevious: boolean;    readonly total?: number;    // Navigation    next(): Promise&lt;CustomPagination&lt;T&gt;&gt;;    previous(): Promise&lt;CustomPagination&lt;T&gt;&gt;;}type CustomPaginationDefinition =     | { strategy: 'offset'; limit?: number }    | { strategy: 'page'; limit?: number }    | { strategy: 'cursor'; limit?: number; key?: string };</code></pre>"
  },
  {
    "id": "resources",
    "name": "Custom Resources",
    "status": "draft",
    "summary": "Standard for defining resource entities and their data strategies (Registry).",
    "description": "<h3>Design Philosophy</h3><p>Just like <code>customElements</code> maps a tag name to a class, <strong>customResources</strong> maps a business entity (e.g. 'user', 'product') to its resource configuration. This allows the application to simply request <code>users</code> without knowing if it comes from GraphQL or REST.</p><h3>Interface Protocol</h3><pre><code class=\"language-typescript\">interface CustomResourceRegistry extends CustomRegistry&lt;ResourceDefinition&gt; {    readonly localName = 'customResources';    define(name: string, def: ResourceDefinition): void;    // Returns the config wrapper for a specific resource    get(name: string): ResourceHandle;}interface ResourceDefinition {    identify?: (params: unknown) => unknown[]; // The Resolver    tracer?: CustomTracer; // e.g. OpenTelemetry    pagination?: CustomPaginationDefinition; // Strategy (Offset/Cursor)}</code></pre>"
  }
]