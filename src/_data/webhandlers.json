{
  "id": "webhandlers",
  "name": "Web Handlers (Speculative)",
  "description": "Speculative protocol for standardizing how event handlers are referenced, resolved, and exposed in HTML-based UI systems. Explores the mapping between string-based event attributes and handler resolution across native HTML, frameworks, and custom behavior systems.",
  "status": "speculative",
  "category": "standard",
  "icon": "/assets/icons/webhandlers.svg",
  "isSvg": true,
  "details": "<h2>Protocol: Web Handlers (Speculative)</h2><p>This protocol explores how event handlers are referenced and resolved in HTML-based systems, focusing on string-based event attributes and their mapping to handler functions or actions. It surveys current approaches and proposes a unified model for handler exposure and lookup.</p><h3>Comparison Table</h3><table><thead><tr><th>Library</th><th>Event Attribute Syntax</th><th>Example Usage</th><th>Handler Exposure (Component)</th><th>Notes</th></tr></thead><tbody><tr><td>Native HTML</td><td>onclick=&quot;...&quot;</td><td>&lt;button onclick=&quot;alert('Hi')&quot;&gt;Click&lt;/button&gt;</td><td>Global function or inline JS code</td><td>String is evaluated in global scope</td></tr><tr><td>Angular</td><td>(event)=&quot;handler()&quot;</td><td>&lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;</td><td>Any public method/property on the component class</td><td>String is parsed as an expression, bound to component scope</td></tr><tr><td>Alpine.js</td><td>@event=&quot;...&quot; or x-on:event=&quot;...&quot;</td><td>&lt;button @click=&quot;open = true&quot;&gt;&lt;/button&gt;</td><td>Any property or method in Alpine component’s data object</td><td>String is evaluated in Alpine’s reactive context</td></tr><tr><td>Vue.js</td><td>v-on:event=&quot;...&quot; or @event=&quot;...&quot;</td><td>&lt;button @click=&quot;doSomething&quot;&gt;&lt;/button&gt;</td><td>Any method defined in the methods option of the component</td><td>String is a method name or expression in component scope</td></tr><tr><td>htmx</td><td>hx-on:event=&quot;...&quot;</td><td>&lt;button hx-on:click=&quot;alert('Hi')&quot;&gt;&lt;/button&gt;</td><td>Global function or inline JS code</td><td>String is evaluated as JS code in global scope</td></tr></tbody></table><h3>Shadow DOM Support and Event Handler Impact</h3><table><thead><tr><th>Library</th><th>Shadow DOM Support</th><th>Event Handler Impact in Shadow DOM</th></tr></thead><tbody><tr><td>Native HTML</td><td>Yes (via Web Components)</td><td>Native events work, but global <code>onclick=&quot;...&quot;</code> only works if the handler is in global scope. Event delegation from outside the shadow root does not cross shadow boundaries.</td></tr><tr><td>Angular</td><td>Partial (via custom elements, not core)</td><td>Angular’s event binding works inside its own component tree, but does not natively integrate with Shadow DOM. If using Angular Elements (custom elements), handlers are still component-scoped.</td></tr><tr><td>Alpine.js</td><td>No native support</td><td>Alpine does not support Shadow DOM; event bindings do not work inside shadow roots.</td></tr><tr><td>Vue.js</td><td>Partial (via <code>vue-custom-element</code> or <code>shadowRoot: true</code>)</td><td>Vue’s event system works inside the component, but event bindings in shadow roots are only supported if using custom element mode. Handlers remain component-scoped.</td></tr><tr><td>htmx</td><td>No native support</td><td>htmx does not support Shadow DOM; event delegation and bindings do not work inside shadow roots.</td></tr></tbody></table><p><strong>Summary:</strong> In Shadow DOM, event handlers must be attached within the shadow root. Global attributes like <code>onclick=&quot;...&quot;</code> only work if the handler is globally accessible. Frameworks that scope handlers to the component instance (Angular, Vue) keep this behavior even in shadow roots, but do not expose handlers globally. Event delegation does not cross shadow boundaries.</p><h3>Observations</h3><ul><li>Native HTML and htmx require handlers to be globally accessible (global function or inline code).</li><li>Angular, Alpine.js, and Vue.js resolve handlers as methods or properties on the component instance or data context.</li><li>String-based event attributes are the most declarative and HTML-aligned, but handler resolution varies widely.</li><li>Frameworks avoid global scope for security and encapsulation, while native HTML and htmx do not.</li><li>Declarative event-to-action mapping (e.g., <code>on:click=&quot;save&quot;</code>) is emerging as a standard for custom behaviors and protocols.</li></ul><h3>Speculative Proposal</h3><ul><li>Standardize a protocol for handler lookup that allows both global and component-scoped resolution.</li><li>Support argument passing via attributes (e.g., <code>arg-*</code>).</li><li>Enable context-aware handler resolution for portals and DI systems.</li></ul><h3>Standalone Handler Resolution: Thought Experiment</h3><p>It is possible to compose an application directly in an HTML file, using string-based event attributes, without relying on the global scope or custom elements. This can be achieved by:</p><ul><li>Declaring handlers in a local registry within a script block.</li><li>Scanning the DOM for custom event attributes (e.g., <code>on:click=&quot;save&quot;</code>).</li><li>Attaching event listeners by resolving handler names from the local registry, not the global scope.</li></ul><p>This approach enables declarative composition and encapsulation in a single file or app context, but is not natively supported by browsers. It requires a small runtime to manage handler lookup and binding. True encapsulation and non-global handler resolution in HTML requires either a component model (custom elements) or a runtime that manages handler lookup and binding. This justifies a standalone Web Handlers protocol, separate from custom elements or custom attributes, to standardize handler resolution and enable advanced composition patterns in HTML-based UIs.</p>"
}
