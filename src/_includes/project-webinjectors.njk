<section id="concept" class="section-card">
    <h3 id="the-concept">The Concept</h3>
    <p>
        <strong>Web Injectors</strong> introduces a first-class language construct related to managing dependency injection and scope flow directly in TypeScript/JavaScript.
        It moves beyond "Import Maps" by allowing dynamic, hierarchical, and domain-based resolution of resources.
    </p>
</section>

<section id="syntax" class="section-card">
    <h3 id="core-syntax">Core Syntax</h3>
    <ul>
        <li><code>injector</code>: Declares a new dependency container. Similar to a <code>namespace</code> or <code>module</code> but specifically for dependency resolution.</li>
        <li><code>provide</code>: Exposes values from an injector to a specific domain or globally.</li>
        <li><code>consume</code>: Injects values from a specific domain into the current scope.</li>
        <li><code>domain</code>: A string identifier (e.g., <code>'@app/core'</code>). <strong>This is the contract.</strong> It acts as a universal namespace that prevents naming collisions (e.g., <code>@auth/session</code> vs <code>@analytics/session</code>) and decouples the interface from the implementation.</li>
    </ul>
</section>

<section id="deep-dive" class="section-card">
    <h3 id="deep-dive-syntax-usage">Deep Dive: Syntax & Usage</h3>

    <h4 id="1-basic-injector-definition">1. Basic Injector Definition</h4>
    <p>An <code>injector</code> is a block that encapsulates resources. You can export it just like a class or variable.</p>
    {% highlight "typescript" %}
// definitions.ts
export injector definitions {
// Define resources inside the injector
const Resource = 100;

// Expose them to the outside world
provide { Resource };
}
    {% endhighlight %}

    <h4 id="2-consuming-dependencies">2. Consuming Dependencies</h4>
    <p>Consumers request resources from a specific "domain" string. This decouples the consumer from the concrete implementation file.</p>
    {% highlight "typescript" %}
// consumer.ts
// We don't import from 'definitions.ts'. 
// We consume from the abstract domain '@definitions'.
consume { Resource } of '@definitions';

const r: number = Resource; // 'Resource' is now available in this scope
    {% endhighlight %}

    <h4 id="3-composition-wiring">3. Composition & Wiring</h4>
    <p>The "Main" or "Root" of the application wires the concrete implementation (<code>definitions</code>) to the abstract domain (<code>@definitions</code>).</p>
    {% highlight "typescript" %}
// main.ts
import { definitions } from "./definitions";

export injector main {
// 1. Contextualize: Map the concrete 'definitions' injector 
//    to the abstract identifier '@definitions'.
provide * to '@definitions' from definitions;

// 2. Include the consumer code into this execution context
provide * from "./consumer";
}
    {% endhighlight %}

    <h4 id="4-fallback-providers">4. Fallback Providers (Polyfills)</h4>
    <p>
        Injectors can provide fallback implementations that are only used if the dependency hasn't been provided by an ancestor.
        This allows libraries to be self-sufficient while remaining extensible.
    </p>
    {% highlight "typescript" %}
injector Component extends import.injector {
    // Will be ignored if 'Logger' exists in the parent scope
    provide { Logger } from import.injector, './console-logger';
}
    {% endhighlight %}
</section>

<!-- CASE STUDY MOVED BELOW -->
</section>


<section id="declarative-html-example" class="section-card">
  <h3 id="declarative-html-injector">Declarative HTML Injector Example</h3>
  <p>
    You can use Web Injectors declaratively in HTML by associating a <code>&lt;script type="injector"&gt;</code> block with a node via the standard <code>id</code> and <code>injector</code> attributes. This enables zero-build, framework-agnostic dependency injection directly in markup.
  </p>

    {% highlight "html" %}
<!-- Define an injector with a unique id -->
<script type="injector" id="theme-injector">
    provide { theme } from './theme-dark.js';
</script>

<!-- Associate a node with the injector by id -->
<my-widget injector="theme-injector"></my-widget>
    {% endhighlight %}
    <p>
        The <code>&lt;script type="injector" id="theme-injector"&gt;</code> block provides the <code>theme</code> value from <code>./theme-dark.js</code>. Any element with <code>injector="theme-injector"</code> will consume dependencies from that injector context.
    </p>

        <h4 id="injector-meta-property">Referencing the Injector Meta Property</h4>
        <p>
            To reference the current injector context (such as for meta/configuration), use <code>injector</code> only in the <strong>from</strong> clause. For example, to provide all custom elements registered in the current injector context:
        </p>
        {% highlight "html" %}
<script type="injector" id="custom-elements-injector">
    provide * of 'customElements' from injector;
</script>
        {% endhighlight %}
        <p>
            Here, <code>injector</code> refers to the current injector context and exposes all custom elements to consumers. The <code>injector</code> identifier is <strong>only</strong> valid in the <code>from</code> clause.
        </p>
    <h4 id="isolate-attribute">The <code>isolate</code> Attribute</h4>
    <p>
        By default, an injector context extends its parent injector. To prevent inheritance and create a fully isolated injector, add the boolean <code>isolate</code> attribute:
    </p>
    {% highlight "html" %}
<script type="injector" id="isolated-injector" isolate>
    provide { theme } from './theme-contrast.js';
</script>
    {% endhighlight %}
    <p>
        When <code>isolate</code> is present, the injector does <strong>not</strong> inherit from any parent context. This is analogous to <code>hidden</code>, <code>inert</code>, and other boolean HTML attributes.
    </p>

    <h4 id="implementation-note">Implementation Note</h4>
    <p>
        The <code>&lt;script type="injector"&gt;</code> functionality uses the <strong>customScriptType</strong> registry, an extensibility point that enables custom script behaviors in HTML. This registry allows defining new script types with specialized upgrade and lifecycle logic. While currently used internally for injectors and contexts (see <a href="/projects/webcontexts/">Web Contexts</a>), this pattern may be formalized for userland use if additional compelling use cases emerge.
    </p>
</section>

<section id="case-study" class="section-card">
    <h3 id="case-study-the-hollow-calendar-widget">Case Study: The "Hollow" Calendar Widget</h3>
    <p>
        Modern UI libraries (like <code>react-calendar</code> or <code>mui-datepicker</code>) are often monolithic bundles containing date math, formatting logic, positioning engines, and styling.
        With <strong>Web Injectors</strong>, we can build a "hollow" widget that delegates all complexity to injected protocols.
    </p>

    <h4 id="deconstructing-the-calendar">Deconstructing the Calendar</h4>
    <p>A rich calendar widget actually encapsulates several distinct domains:</p>
    <div class="features-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
        <div class="content-box" style="padding: 1rem;">
            <strong>Date Logic</strong>
            <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Adding months, calculating start-of-week, validation.</p>
            <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/core</code>
        </div>
        <div class="content-box" style="padding: 1rem;">
            <strong>Localization</strong>
            <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Formatting "MMMM YYYY", day names "Mon/Tue".</p>
            <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@date/fmt</code>
        </div>
        <div class="content-box" style="padding: 1rem;">
            <strong>Positioning</strong>
            <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Floating element anchor, collision detection.</p>
            <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/floating</code>
        </div>
        <div class="content-box" style="padding: 1rem;">
            <strong>Icons</strong>
            <p style="font-size: 0.9rem; margin: 0; color: var(--color-text-muted);">Chevron Left/Right, Calendar icon.</p>
            <code style="font-size: 0.8rem; display: block; margin-top: 0.5rem; color: var(--color-primary);">@ui/icons</code>
        </div>
    </div>

    <h4 id="the-widget-implementation">The Widget Implementation</h4>
    <p>Notice how the component below contains <strong>zero</strong> implementation logic. It is purely an orchestrator.</p>

    {% highlight "typescript" %}
// components/calendar.ts
// -----------------------
// 1. Declare dependencies on abstract domains
consume { addMonths, startOfMonth, getDaysInMonth } of '@date/core';
consume { format }                                  of '@date/fmt';
consume { useFloating, offset, flip }               of '@ui/floating';
consume { ChevronLeft, ChevronRight }               of '@ui/icons';

export class HollowCalendar extends HTMLElement {
connectedCallback() {
this.render();
}

render() {
// 2. Use the injected 'format' function
// The widget doesn't know if this is using Intl, date-fns, or moment.
const title = format(new Date(), 'MMMM yyyy');

// 3. Use the injected 'Chevron' icons
// The widget doesn't know if these are SVGs, FontAwesome, or Images.
this.innerHTML = `
<header>
    <button>${ChevronLeft}</button>
    <span>${title}</span>
    <button>${ChevronRight}</button>
</header>
<div class="grid">
    <!-- Days rendered here using injected math -->
</div>
`;
}
}
{% endhighlight %}

<h4 id="the-wiring-application-root">The Wiring (Application Root)</h4>
<p>This is where we decide <em>how</em> the calendar behaves in this specific application.</p>

{% highlight "typescript" %}
// app.ts
import { DateFnsAdapter } from "./adapters/date-fns";
import { FloatingUIDOM } from "./adapters/floating-ui";
import { FontAwesomeIcons } from "./theme/fa-icons";

// Create the unified environment
export injector AppEnvironment {
// Bind specific libraries to the abstract domains
provide * to '@date/core'     from DateFnsAdapter;
provide * to '@date/fmt'      from DateFnsAdapter;
provide * to '@ui/floating'   from FloatingUIDOM;
provide * to '@ui/icons'      from FontAwesomeIcons;
}

// Now render the app
// <hollow-calendar> will automatically receive the provided implementations.
    {% endhighlight %}
</section>


<section id="why" class="section-card">
    <h3 id="why-this-matters">Why This Matters?</h3>
    <p>
        This pattern allows for true <strong>Inversion of Control</strong> at the language level.
        Your <code>consumer.ts</code> never needs to know where <code>Resource</code> comes from, or even if it was mocked for testing.
        The <code>main</code> injector acts as the composition root, binding <code>RealService</code> to <code>@service</code> in production, or <code>MockService</code> to <code>@service</code> in tests.
    </p>
</section>

<section id="dom-api" class="section-card">
  <h3 id="dom-api-reference">DOM API Reference</h3>
  <p>
    This section documents the proposed DOM API extensions for working with injectors. These APIs extend the <code>Node</code> interface to support hierarchical injector lookup and management throughout the DOM tree.
  </p>

  <h4 id="injector-lookup">Injector Lookup Methods</h4>
  <p>Methods for accessing and navigating the injector hierarchy:</p>

  <dl style="margin-left: 1rem;">
    <dt><code>node.getOwnInjector(): HTMLInjector | null</code></dt>
    <dd>Returns the injector owned by this specific node, or <code>null</code> if the node doesn't have its own injector. Only returns an injector if this node explicitly defines one (via <code>injector</code> attribute or <code>&lt;script type="injector"&gt;</code>).</dd>

    <dt><code>node.hasOwnInjector(): boolean</code></dt>
    <dd>Returns <code>true</code> if this node has its own injector, <code>false</code> otherwise. Convenience method equivalent to <code>Boolean(node.getOwnInjector())</code>.</dd>

    <dt><code>node.getClosestInjector(): HTMLInjector | null</code></dt>
    <dd>Returns the closest injector in the DOM tree hierarchy, walking up from this node. Searches through parent elements, shadow roots, and template boundaries. Returns <code>null</code> if no injector is found in the ancestry.</dd>

    <dt><code>node.injectors(): Generator&lt;HTMLInjector&gt;</code></dt>
    <dd>Returns a generator that yields all injectors in the hierarchy, starting from the closest. Each iteration yields the next ancestor injector, walking up to the root. Useful for exhaustive searches across multiple injector layers.</dd>
  </dl>

  <h4 id="element-creation">Element Creation</h4>
  <p>Context-aware element creation using the injector hierarchy:</p>

  <dl style="margin-left: 1rem;">
    <dt><code>node.createElement(tagName: string, options?: ElementCreationOptions): HTMLElement</code></dt>
    <dd>Creates an element using the context-aware custom element registry. Searches through the injector hierarchy for custom element definitions. Falls back to standard <code>document.createElement()</code> if no custom definition is found. This enables scoped custom element registration per injector.</dd>
  </dl>

  <h4 id="usage-examples">Usage Examples</h4>
  {% highlight "javascript" %}
// Get the closest injector
const injector = element.getClosestInjector();

// Check if an element has its own injector
if (element.hasOwnInjector()) {
  console.log('Element defines its own dependency scope');
}

// Create a custom element from the injector's registry
const customEl = element.createElement('my-component');

// Iterate through all injectors in the hierarchy
for (const injector of element.injectors()) {
  console.log('Found injector:', injector);
  // Access injector's provided values
  const theme = injector.get('theme');
}

// Access a specific dependency from the injector
const currentInjector = node.getClosestInjector();
const logger = currentInjector.get('logger');
logger.info('Accessed from injector hierarchy');
  {% endhighlight %}

  <h4 id="design-principles">Key Design Principles</h4>
  <ul>
    <li><strong>Hierarchical:</strong> Injector lookups traverse the DOM tree hierarchy, enabling nested scopes</li>
    <li><strong>Lazy:</strong> Injectors are created on-demand when first accessed</li>
    <li><strong>Scoped:</strong> Each node can own its own injector with isolated or inherited dependencies</li>
    <li><strong>Traversal-aware:</strong> Injector lookup respects shadow DOM and template boundaries</li>
    <li><strong>Generator-based:</strong> The <code>injectors()</code> API uses generators for efficient iteration without building arrays</li>
  </ul>
</section>